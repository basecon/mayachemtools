.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MiscUtil 1"
.TH MiscUtil 1 "2020-08-27" "perl v5.22.4" "MayaChemTools"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MiscUtil
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
import MiscUtil
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBMiscUtil\fR module provides the following functions:
.PP
CheckFileExt, CheckTextValue, DoesSMILESFileContainTitleLine, ExpandFileNames,
GetExamplesTextFromDocOptText, GetExcelStyleColumnLabel, GetFormattedElapsedTime,
GetFormattedFileSize, GetMayaChemToolsLibDataPath, GetTextLines,
GetTextLinesWords, GetWallClockAndProcessorTime, IsEmpty, IsFloat, IsInteger,
IsNumber, JoinWords, ObjectFromBase64EncodedString, ObjectToBase64EncodedString,
ParseFileName, PrintError, PrintInfo, PrintWarning, ProcessOptionInfileParameters,
ProcessOptionMultiprocessingParameters, ProcessOptionOutfileParameters,
ProcessOptionSeabornPlotParameters, ReplaceHTMLEntitiesInText, TruncateText,
ValidateOptionFileExt, ValidateOptionFilePath, ValidateOptionFloatValue,
ValidateOptionIntegerValue, ValidateOptionNumberValue, ValidateOptionNumberValues,
ValidateOptionTextValue, ValidateOptionsDistinctFileNames,
ValidateOptionsOutputFileOverwrite, WrapText
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\fBCheckFileExt\fR" 4
.IX Item "CheckFileExt"
.Vb 1
\&    CheckFileExt(FileName, FileExts)
.Ve
.Sp
Check file type based on the specified file extensions delimited by spaces.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 2
\&    FileName (str): Name of a file.
\&    FileExts (str): Space delimited string containing valid file extensions.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    bool : True, FileName contains a valid file extension; Otherwise, False.
.Ve
.IP "\fBCheckTextValue\fR" 4
.IX Item "CheckTextValue"
.Vb 1
\&    CheckTextValue(Value, ValidValues)
.Ve
.Sp
Check text value based on the specified valid values delimited by spaces.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 2
\&    Value (str): Text value
\&    ValidValues (str): Space delimited string containing valid values.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    bool : True, Value is valid; Otherwise, False.
.Ve
.IP "\fBDoesSMILESFileContainTitleLine\fR" 4
.IX Item "DoesSMILESFileContainTitleLine"
.Vb 1
\&    DoesSMILESFileContainTitleLine(FileName)
.Ve
.Sp
Determine whether the \s-1SMILES\s0 file contain a title line based on the  presence
of a string \s-1SMILES,\s0 Name or \s-1ID\s0 in the first line.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    FileName (str): Name of a file.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    bool : True, File contains title line; Otherwise, False.
.Ve
.IP "\fBExpandFileNames\fR" 4
.IX Item "ExpandFileNames"
.Vb 1
\&    ExpandFileNames(FilesSpec, Delimiter = ",")
.Ve
.Sp
Expand files specification using glob module to process any * or ? wild
cards in file names and return a list of expanded file names.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 2
\&    FilesSpec (str): Files specifications
\&    Delimiter (str): Delimiter for file specifications
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    list : List of expanded file names
.Ve
.IP "\fBGetExamplesTextFromDocOptText\fR" 4
.IX Item "GetExamplesTextFromDocOptText"
.Vb 1
\&    GetExamplesTextFromDocOptText(DocOptText)
.Ve
.Sp
Get script usage example lines from a docopt doc string. The example text
line start from a line containing `Examples:`  keyword at the beginning of the line.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 2
\&    DocOptText (str): Doc string containing script usage examples lines starting with
\&        a line marked by \`Examples:\` keyword at the beginning of a line.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 2
\&    str : A string containing text lines retrieved from the examples section of
\&        DocOptText parameter.
.Ve
.IP "\fBGetExcelStyleColumnLabel\fR" 4
.IX Item "GetExcelStyleColumnLabel"
.Vb 1
\&    GetExcelStyleColumnLabel(ColNum)
.Ve
.Sp
Return Excel style column label for a colum number.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    ColNum (int): Column number
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    str : Excel style column label.
.Ve
.IP "\fBGetFormattedElapsedTime\fR" 4
.IX Item "GetFormattedElapsedTime"
.Vb 1
\&    GetFormattedElapsedTime(StartingWallClockTime, StartingProcessorTime)
.Ve
.Sp
Get elapsed wallclock and processor times  as a string in the following
format: \f(CW%d\fR wallclock secs ( %.2f process secs).
.Sp
\&\fIArguments:\fR
.Sp
.Vb 2
\&    StartingWallClockTime (float): Starting wallclock time in seconds.
\&    StartingProcessorTime (float): Starting processor time in seconds.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    str : Elapsed time formatted as: %d wallclock secs ( %.2f process secs)
.Ve
.IP "\fBGetFormattedFileSize\fR" 4
.IX Item "GetFormattedFileSize"
.Vb 1
\&    GetFormattedFileSize(FileName, Precision = 1)
.Ve
.Sp
Get file size  as a string in the following format: %.*f <bytes, \s-1KB, MB,
GB\s0>
.Sp
\&\fIArguments:\fR
.Sp
.Vb 2
\&    FileName (str): File path.
\&    Precision (int): File size precision.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    str : File size formatted as: %.2f <bytes, KB, MB, GB>
.Ve
.IP "\fBGetMayaChemToolsLibDataPath\fR" 4
.IX Item "GetMayaChemToolsLibDataPath"
.Vb 1
\&    GetMayaChemToolsLibDataPath()
.Ve
.Sp
Get location of MayaChemTools lib data directory.
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    str : Location of MayaChemTools lib data directory.
.Ve
.Sp
The location of MayaChemTools lib data directory is determined relative to
MayaChemTools python lib directory name available through sys.path.
.IP "\fBGetTextLines\fR" 4
.IX Item "GetTextLines"
.Vb 1
\&    GetTextLines(TextFilePath)
.Ve
.Sp
Read text lines from input file, remove new line characters  and return a list containing
stripped lines.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    TextFilePath (str): Text file name including file path.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    list : A list lines.
.Ve
.IP "\fBGetTextLinesWords\fR" 4
.IX Item "GetTextLinesWords"
.Vb 1
\&    GetTextLinesWords(TextFilePath, Delimiter, QuoteChar, IgnoreHeaderLine)
.Ve
.Sp
Parse lines in the specified text file into words in a line and return a list containing
list of parsed line words.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 5
\&    TextFilePath (str): Text file name including file path.
\&    Delimiter (str): Delimiter for parsing text lines.
\&    QuoteChar (str): Quote character for line words.
\&    IgnoreHeaderLine (bool): A flag indicating whether to ignore first
\&        valid data line corresponding to header line.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    list : A list of lists containing parsed words for lines.
.Ve
.Sp
The lines starting with # or // are considered comment lines and are
ignored during parsing along with any empty lines.
.IP "\fBGetWallClockAndProcessorTime\fR" 4
.IX Item "GetWallClockAndProcessorTime"
.Vb 1
\&    GetWallClockAndProcessorTime()
.Ve
.Sp
Get wallclock and processor times in seconds.
.Sp
\&\fIReturns:\fR
.Sp
.Vb 2
\&    float : Wallclock time.
\&    float : Processor time.
.Ve
.IP "\fBIsEmpty\fR" 4
.IX Item "IsEmpty"
.Vb 1
\&    IsEmpty(Value)
.Ve
.Sp
Determine whether the specified value is empty after converting
it in to a string and removing all leading and trailing white spaces. A  value
of type None is considered empty.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    Value (str, int or float): Text or a value
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    bool : True, Text string is empty; Otherwsie, False.
.Ve
.IP "\fBIsFloat\fR" 4
.IX Item "IsFloat"
.Vb 1
\&    IsFloat(Value)
.Ve
.Sp
Determine whether the specified value is a float by converting it
into a float.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    Value (str, int or float): Text
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    bool : True, Value is a float; Otherwsie, False.
.Ve
.IP "\fBIsInteger\fR" 4
.IX Item "IsInteger"
.Vb 1
\&    IsInteger(Value)
.Ve
.Sp
Determine whether the specified value is an integer by converting it
into an int.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    Value (str, int or float): Text
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    bool : True, Value is an integer; Otherwsie, False.
.Ve
.IP "\fBIsNumber\fR" 4
.IX Item "IsNumber"
.Vb 1
\&    IsNumber(Value)
.Ve
.Sp
Determine whether the specified value is a number by converting it
into a float.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    Value (str, int or float): Text
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    bool : True, Value is a number; Otherwsie, False.
.Ve
.IP "\fBJoinWords\fR" 4
.IX Item "JoinWords"
.Vb 1
\&    JoinWords(Words, Delimiter, Quote = False)
.Ve
.Sp
Join words in a list using specified delimiter with optional quotes around words.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 3
\&    Words (list): List containing words to join.
\&    Delimiter (string): Delimiter for joining words.
\&    Quote (boolean): Put quotes around words.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    str : String containing joined words.
.Ve
.IP "\fBObjectFromBase64EncodedString\fR" 4
.IX Item "ObjectFromBase64EncodedString"
.Vb 1
\&    ObjectFromBase64EncodedString(EncodedObject)
.Ve
.Sp
Generate Python object from a bas64 encoded and pickled
object string.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    str: Base64 encoded and pickled object string.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    object : Python object or None.
.Ve
.IP "\fBObjectToBase64EncodedString\fR" 4
.IX Item "ObjectToBase64EncodedString"
.Vb 1
\&    ObjectToBase64EncodedString(Object)
.Ve
.Sp
Encode Python object into base64 encoded string. The object is
pickled before encoding.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    object: Python object.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    str : Base64 encode object string or None.
.Ve
.IP "\fBParseFileName\fR" 4
.IX Item "ParseFileName"
.Vb 1
\&    ParseFileName(FilePath)
.Ve
.Sp
Parse specified file path and return file dir, file name, and file extension.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    FilePath (str): Name of a file with complete file path.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 3
\&    str : File directory.
\&    str : File name without file extension.
\&    str : File extension.
.Ve
.IP "\fBPrintError\fR" 4
.IX Item "PrintError"
.Vb 1
\&    PrintError(Msg, Status=1)
.Ve
.Sp
Print message to stderr along with flushing stderr and exit with a specified
status. An `Error` prefix is placed before the message.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 2
\&    Msg (str): Text message.
\&    Status (int): Exit status.
.Ve
.IP "\fBPrintInfo\fR" 4
.IX Item "PrintInfo"
.Vb 1
\&    PrintInfo(Msg=\*(Aq\*(Aq)
.Ve
.Sp
Print message to stderr along with flushing stderr.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    Msg (str): Text message.
.Ve
.IP "\fBPrintWarning\fR" 4
.IX Item "PrintWarning"
.Vb 1
\&    PrintWarning(msg)
.Ve
.Sp
Print message to stderr along with flushing stderr. An `Warning` prefix
is placed before the message.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    Msg (str): Text message.
.Ve
.IP "\fBProcessOptionInfileParameters\fR" 4
.IX Item "ProcessOptionInfileParameters"
.Vb 1
\&    ProcessOptionInfileParameters(ParamsOptionName, ParamsOptionValue, InfileName = None, OutfileName = None)
.Ve
.Sp
Process parameters for reading input files and return a map containing
processed parameter names and values.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 4
\&    ParamsOptionName (str): Command line input parameters option name.
\&    ParamsOptionValues (str): Comma delimited list of parameter name and value pairs.
\&    InfileName (str): Name of input file.
\&    OutfileName (str): Name of output file.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    dictionary: Processed parameter name and value pairs.
.Ve
.Sp
The parameter name and values specified in ParamsOptionValues are validated before
returning them in a dictionary.
.IP "\fBProcessOptionMultiprocessingParameters\fR" 4
.IX Item "ProcessOptionMultiprocessingParameters"
.Vb 1
\&    ProcessOptionMultiprocessingParameters(ParamsOptionName, ParamsOptionValue)
.Ve
.Sp
Process parameters for multiprocessing and return a map containing processed
parameter names and values.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 2
\&    ParamsOptionName (str): Command line multiprocessing parameters option name.
\&    ParamsOptionValues (str): Comma delimited list of parameter name and value pairs.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    dictionary: Processed parameter name and value pairs.
.Ve
.Sp
The parameter name and values specified in ParamsOptionValues are validated before
returning them in a dictionary.
.IP "\fBProcessOptionOutfileParameters\fR" 4
.IX Item "ProcessOptionOutfileParameters"
.Vb 1
\&    ProcessOptionOutfileParameters(ParamsOptionName, ParamsOptionValue, InfileName = None, OutfileName = None)
.Ve
.Sp
Process parameters for writing output files and return a map containing
processed parameter names and values.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 4
\&    ParamsOptionName (str): Command line input parameters option name.
\&    ParamsOptionValues (str): Comma delimited list of parameter name and value pairs.
\&    InfileName (str): Name of input file.
\&    OutfileName (str): Name of output file.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    dictionary: Processed parameter name and value pairs.
.Ve
.Sp
The parameter name and values specified in ParamsOptionValues are validated before
returning them in a dictionary.
.Sp
The default value of some parameters may depend on type of input file. Consequently,
the input file name is also needed.
.IP "\fBProcessOptionSeabornPlotParameters\fR" 4
.IX Item "ProcessOptionSeabornPlotParameters"
.Vb 1
\&    ProcessOptionSeabornPlotParameters(ParamsOptionName, ParamsOptionValue, ParamsDefaultInfo = None)
.Ve
.Sp
Process parameters for generating Seaborn plots and return a map containing
processed parameter names and values.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 3
\&    ParamsOptionName (str): Command line seaborn parameters option name.
\&    ParamsOptionValues (str): Comma delimited list of parameter name and value pairs.
\&    ParamsDefaultValues (dict): Default values for selected parameters.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    dictionary: Processed parameter name and value pairs.
.Ve
.Sp
The parameter name and values specified in ParamsOptionValues are validated before
returning them in a dictionary.
.IP "\fBReplaceHTMLEntitiesInText\fR" 4
.IX Item "ReplaceHTMLEntitiesInText"
.Vb 1
\&    ReplaceHTMLEntitiesInText(Text)
.Ve
.Sp
Check and replace the followng \s-1HTML\s0 entities to their respective code
for display in a browser: < (less than), > (greater than), & (ampersand),
" (double quote),  and ' (single quote).
.Sp
\&\fIArguments:\fR
.Sp
.Vb 1
\&    Text (str): Text value.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    str : Modifed text value.
.Ve
.IP "\fBTruncateText\fR" 4
.IX Item "TruncateText"
.Vb 1
\&    TruncateText(Text, Width, TrailingChars = "...")
.Ve
.Sp
Truncate text using specified width along with appending any trailing
characters.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 3
\&    Text (string): Input text.
\&    Width (int): Max number of characters before truncating text.
\&    Delimiter (string): Trailing characters to append or None.
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    str : Truncated text
.Ve
.IP "\fBValidateOptionFileExt\fR" 4
.IX Item "ValidateOptionFileExt"
.Vb 1
\&    ValidateOptionFileExt(OptionName, FileName, FileExts)
.Ve
.Sp
Validate file type based on the specified file extensions delimited by spaces.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 3
\&    OptionName (str): Command line option name.
\&    FileName (str): Name of a file.
\&    FileExts (str): Space delimited string containing valid file extensions.
.Ve
.Sp
The function exits with an error message for a file name containing
invalid file extension.
.IP "\fBValidateOptionFilePath\fR" 4
.IX Item "ValidateOptionFilePath"
.Vb 1
\&    ValidateOptionFilePath(OptionName, FilePath)
.Ve
.Sp
Validate presence of the file.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 2
\&    OptionName (str): Command line option name.
\&    FilePath (str): Name of a file with complete path.
.Ve
.Sp
The function exits with an error message for a file path that doesn't exist.
.IP "\fBValidateOptionFloatValue\fR" 4
.IX Item "ValidateOptionFloatValue"
.Vb 1
\&    ValidateOptionFloatValue(OptionName, OptionValue, CmpOpValueMap)
.Ve
.Sp
Validate option value using comparison operater and value pairs in specified in
a map.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 4
\&    OptionName (str): Command line option name.
\&    OptionValue (float or str): Command line option value.
\&    CmpOpValueMap (dictionary): Comparison operator key and value pairs to
\&        validate values specified in OptionValue.
.Ve
.Sp
The function exits with an error message for an invalid option values specified
in OptionValue.
.Sp
\&\fIExample(s):\fR
.Sp
.Vb 3
\&    ValidateOptionNumberValue("\-b, \-\-butinaSimilarityCutoff", 
\&        Options["\-\-butinaSimilarityCutoff"],
\&        {">": 0.0, "<=" : 1.0})
.Ve
.IP "\fBValidateOptionIntegerValue\fR" 4
.IX Item "ValidateOptionIntegerValue"
.Vb 1
\&    ValidateOptionIntegerValue(OptionName, OptionValue, CmpOpValueMap)
.Ve
.Sp
Validate option value using comparison operater and value pairs in specified in
a map.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 4
\&    OptionName (str): Command line option name.
\&    OptionValue (int or str): Command line option value.
\&    CmpOpValueMap (dictionary): Comparison operator key and value pairs to
\&        validate values specified in OptionValue.
.Ve
.Sp
The function exits with an error message for an invalid option values specified
in OptionValue.
.Sp
\&\fIExample(s):\fR
.Sp
.Vb 2
\&    ValidateOptionIntegerValue("\-\-maxConfs", Options["\-\-maxConfs"],
\&        {">": 0})
.Ve
.IP "\fBValidateOptionNumberValue\fR" 4
.IX Item "ValidateOptionNumberValue"
.Vb 1
\&    ValidateOptionNumberValue(OptionName, OptionValue, CmpOpValueMap)
.Ve
.Sp
Validate option value using comparison operater and value pairs in specified in
a map.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 4
\&    OptionName (str): Command line option name.
\&    OptionValue (int or float): Command line option value.
\&    CmpOpValueMap (dictionary): Comparison operator key and value pairs to
\&        validate values specified in OptionValue.
.Ve
.Sp
The function exits with an error message for an invalid option values specified
in OptionValue.
.Sp
\&\fIExample(s):\fR
.Sp
.Vb 5
\&    ValidateOptionNumberValue("\-\-maxConfs", int(Options["\-\-maxConfs"]),
\&        {">": 0})
\&    ValidateOptionNumberValue("\-b, \-\-butinaSimilarityCutoff", 
\&        float(Options["\-\-butinaSimilarityCutoff"]),
\&        {">": 0.0, "<=" : 1.0})
.Ve
.IP "\fBValidateOptionNumberValues\fR" 4
.IX Item "ValidateOptionNumberValues"
.Vb 1
\&    ValidateOptionNumberValues(OptionName, OptionValueString, OptionValueCount, OptionValueDelimiter, OptionValueType, CmpOpValueMap)
.Ve
.Sp
Validate numerical option values using option value string, delimiter, value type,
and a specified map containing comparison operator and value pairs.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 7
\&    OptionName (str): Command line option name.
\&    OptionValueString (str): Command line option value.
\&    OptionValueCount (int): Number of values in OptionValueString.
\&    OptionValueDelimiter (str): Delimiter used for values in OptionValueString.
\&    OptionValueType (str): Valid number types (integer or float)
\&    CmpOpValueMap (dictionary): Comparison operator key and value pairs to
\&        validate values specified in OptionValueString.
.Ve
.Sp
The function exits with an error message for invalid option values specified
in OptionValueString
.Sp
\&\fIExample(s):\fR
.Sp
.Vb 2
\&    ValidateOptionNumberValues("\-m, \-\-molImageSize",
\&        Options["\-\-molImageSize"], 2, ",", "integer", {">": 0})
.Ve
.IP "\fBValidateOptionTextValue\fR" 4
.IX Item "ValidateOptionTextValue"
.Vb 1
\&    ValidateOptionTextValue(OptionName, OptionValue, ValidValues)
.Ve
.Sp
Validate option value based on the valid specified values separated by spaces.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 3
\&    OptionName (str): Command line option name.
\&    OptionValue (str): Command line option value.
\&    ValidValues (str): Space delimited string containing valid values.
.Ve
.Sp
The function exits with an error message for an invalid option value.
.IP "\fBValidateOptionsDistinctFileNames\fR" 4
.IX Item "ValidateOptionsDistinctFileNames"
.Vb 1
\&    ValidateOptionsDistinctFileNames(OptionName1, FilePath1, OptionName2, FilePath2)
.Ve
.Sp
Validate two distinct file names.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 4
\&    OptionName1 (str): Command line option name.
\&    FilePath1 (str): Name of a file with complete file path.
\&    OptionName2 (str): Command line option name.
\&    FilePath2 (str): Name of a file with complete file path.
.Ve
.Sp
The function exits with an error message for two non distinct file names.
.IP "\fBValidateOptionsOutputFileOverwrite\fR" 4
.IX Item "ValidateOptionsOutputFileOverwrite"
.Vb 1
\&    ValidateOptionsOutputFileOverwrite(OptionName, FilePath, OverwriteOptionName, OverwriteStatus)
.Ve
.Sp
Validate overwriting of output file.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 4
\&    OptionName (str): Command line option name.
\&    FilePath (str): Name of a file with complete file path.
\&    OverwriteOptionName (str): Overwrite command line option name.
\&    OverwriteStatus (bool): True, overwrite
.Ve
.Sp
The function exits with an error message for a file that is present and is not allowed
to be written as indicated by value of OverwriteStatus.
.IP "\fBWrapText\fR" 4
.IX Item "WrapText"
.Vb 1
\&    WrapText(Text, Delimiter, Width)
.Ve
.Sp
Wrap text using specified delimiter and width.
.Sp
\&\fIArguments:\fR
.Sp
.Vb 3
\&    Text (string): Input text
\&    Delimiter (string): Delimiter for wrapping text
\&    Width (int): Max number of characters before wrapping text
.Ve
.Sp
\&\fIReturns:\fR
.Sp
.Vb 1
\&    str : Wrapped text
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Manish Sud <msud@san.rr.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2020 Manish Sud. All rights reserved.
.PP
This file is part of MayaChemTools.
.PP
MayaChemTools is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option) any
later version.
