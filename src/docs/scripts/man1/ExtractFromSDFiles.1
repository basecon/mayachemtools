.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "ExtractFromSDFiles 1"
.TH ExtractFromSDFiles 1 "2020-08-27" "perl v5.22.4" "MayaChemTools"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ExtractFromSDFiles.pl \- Extract specific data from SDFile(s)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
ExtractFromSDFiles.pl SDFile(s)...
.PP
ExtractFromSDFiles.pl [\fB\-h, \-\-help\fR]
[\fB\-d, \-\-datafields\fR \*(L"fieldlabel,...\*(R" | \*(L"fieldlabel,value,criteria...\*(R" | \*(L"fieldlabel,value,value...\*(R"]
[\fB\-\-datafieldsfile\fR filename] [\fB\-\-indelim\fR comma | tab | semicolon] [\fB\-m, \-\-mode\fR alldatafields |
commondatafields | | datafieldnotbylist | datafields | datafieldsbyvalue | datafieldsbyregex | datafieldbylist |
datafielduniquebylist | molnames | randomcmpds | recordnum | recordnums | recordrange | 2dcmpdrecords |
3dcmpdrecords ] [\fB\-n, \-\-numofcmpds\fR number] [\fB\-\-outdelim\fR comma | tab | semicolon]
[\fB\-\-output\fR \s-1SD\s0 | text | both] [\fB\-o, \-\-overwrite\fR] [\fB\-q, \-\-quote\fR yes | no]
[\fB\-\-record\fR recnum | startrecnum,endrecnum] \fB\-\-RegexIgnoreCase\fR \fIyes or no\fR
[\fB\-r, \-\-root\fR rootname] [\fB\-s, \-\-seed\fR number] [\fB\-\-StrDataString\fR yes | no]
[\fB\-\-StrDataStringDelimiter\fR text] [\fB\-\-StrDataStringMode\fR StrOnly | StrAndDataFields]
[\fB\-\-ValueComparisonMode\fR \fINumeric | Alphanumeric\fR]
[\fB\-v, \-\-violations\-\fR number] [\fB\-w, \-\-workingdir\fR dirname] SDFile(s)...
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Extract specific data from \fISDFile(s)\fR and generate appropriate \s-1SD\s0 or \s-1CSV/TSV\s0 text
file(s). The structure data from SDFile(s) is not transferred to \s-1CSV/TSV\s0 text file(s).
Multiple SDFile names are separated by spaces. The valid file extensions are \fI.sdf\fR
and \fI.sd\fR. All other file names are ignored. All the \s-1SD\s0 files in a current directory
can be specified either by \fI*.sdf\fR or the current directory name.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\fB\-h, \-\-help\fR" 4
.IX Item "-h, --help"
Print this help message.
.ie n .IP "\fB\-d, \-\-datafields\fR \fI""fieldlabel,..."" | ""fieldlabel,value,criteria..."" | ""fieldlabel,value,value,...""\fR" 4
.el .IP "\fB\-d, \-\-datafields\fR \fI``fieldlabel,...'' | ``fieldlabel,value,criteria...'' | ``fieldlabel,value,value,...''\fR" 4
.IX Item "-d, --datafields fieldlabel,... | fieldlabel,value,criteria... | fieldlabel,value,value,..."
This value is mode specific. In general, it's a list of comma separated data field labels
and associated mode specific values.
.Sp
For \fIdatafields\fR mode, input value format is: \fIfieldlabel,...\fR. Examples:
.Sp
.Vb 2
\&    Extreg
\&    Extreg,CompoundName,ID
.Ve
.Sp
For \fIdatafieldsbyvalue\fR mode, input value format contains these triplets:
\&\fIfieldlabel,value, criteria...\fR. Possible values for criteria: \fIle, ge or eq\fR.
The values of \fB\-\-ValueComparisonMode\fR indicates whether values are
compared numerical or string comarison operators. Default is to consider
data field values as numerical values and use numerical comparison operators.
Examples:
.Sp
.Vb 2
\&    MolWt,450,le
\&    MolWt,450,le,LogP,5,le,SumNumNO,10,le,SumNHOH,5,le
.Ve
.Sp
For \fIdatafieldsbyregex\fR mode, input value format contains these triplets:
\&\fIfieldlabel,regex, criteria...\fR. \fIregex\fR corresponds to any valid regular expression
and is used to match the values for specified \fIfieldlabel\fR. Possible values for criteria:
 \fIeq or ne\fR. During \fIeq\fR and \fIne\fR values, data field label value is matched with
regular expression using =~ and !~ respectively. \fB\-\-RegexIgnoreCase\fR option
value is used to determine whether to ignore letter upper/lower case during
regular expression match. Examples:
.Sp
.Vb 2
\&    Name,ol,eq
\&    Name,\*(Aq^pat\*(Aq,ne
.Ve
.Sp
For \fIdatafieldbylist\fR and \fIdatafielduniquebylist\fR mode, input value format is:
\&\fIfieldlabel,value1,value2...\fR. This is equivalent to \fIdatafieldsbyvalue\fR mode with
this input value format:\fIfieldlabel,value1,eq,fieldlabel,value2,eq,...\fR. For
\&\fIdatafielduniquebylist\fR mode, only unique compounds identified by first occurrence
of \fIvalue\fR associated with \fIfieldlabel\fR in \fISDFile(s)\fR are kept; any subsequent compounds
are simply ignored.
.Sp
For \fIdatafieldnotbylist\fR mode, input value format is: \fIfieldlabel,value1,value2...\fR. In this
mode, the script behaves exactly opposite of \fIdatafieldbylist\fR mode, and only those compounds
are extracted whose data field values don't match any specified data field value.
.IP "\fB\-\-datafieldsfile\fR \fIfilename\fR" 4
.IX Item "--datafieldsfile filename"
Filename which contains various mode specific values. This option provides a way
to specify mode specific values in a file instead of entering them on the command
line using \fB\-d \-\-datafields\fR.
.Sp
For \fIdatafields\fR mode, input file lines contain comma delimited field labels:
\&\fIfieldlabel,...\fR. Example:
.Sp
.Vb 2
\&    Line 1:MolId
\&    Line 2:"Extreg",CompoundName,ID
.Ve
.Sp
For \fIdatafieldsbyvalue\fR mode, input file lines contains these comma separated triplets:
\&\fIfieldlabel,value, criteria\fR. Possible values for criteria: \fIle, ge or eq\fR. Examples:
.Sp
.Vb 1
\&    Line 1:MolWt,450,le
\&
\&    Line 1:"MolWt",450,le,"LogP",5,le,"SumNumNO",10,le,"SumNHOH",5,le
\&
\&    Line 1:MolWt,450,le
\&    Line 2:"LogP",5,le
\&    Line 3:"SumNumNO",10,le
\&    Line 4: SumNHOH,5,le
.Ve
.Sp
For \fIdatafieldbylist\fR and \fIdatafielduniquebylist\fR mode, input file line format is:
.Sp
.Vb 2
\&    Line 1:fieldlabel;
\&    Subsequent lines:value1,value2...
.Ve
.Sp
For \fIdatafieldbylist\fR, \fIdatafielduniquebylist\fR, and \fIdatafieldnotbylist\fR mode, input file
line format is:
.Sp
.Vb 2
\&    Line 1:fieldlabel;
\&    Subsequent lines:value1,value2...
.Ve
.Sp
For \fIdatafielduniquebylist\fR mode, only unique compounds identified by first occurrence
of \fIvalue\fR associated with \fIfieldlabel\fR in \fISDFile(s)\fR are kept; any subsequent compounds
are simply ignored. Example:
.Sp
.Vb 5
\&    Line 1: MolID
\&    Subsequent Lines:
\&    907508
\&    832291,4642
\&    "1254","907303"
.Ve
.IP "\fB\-\-indelim\fR \fIcomma | tab | semicolon\fR" 4
.IX Item "--indelim comma | tab | semicolon"
Delimiter used to specify text values for \fB\-d \-\-datafields\fR and \fB\-\-datafieldsfile\fR options.
Possible values: \fIcomma, tab, or semicolon\fR. Default value: \fIcomma\fR.
.IP "\fB\-m, \-\-mode\fR \fIalldatafields | commondatafields | datafields | datafieldsbyvalue | datafieldsbyregex | datafieldbylist | datafielduniquebylist |  datafieldnotbylist | molnames | randomcmpds | recordnum | recordnums | recordrange | 2dcmpdrecords | 3dcmpdrecords\fR" 4
.IX Item "-m, --mode alldatafields | commondatafields | datafields | datafieldsbyvalue | datafieldsbyregex | datafieldbylist | datafielduniquebylist | datafieldnotbylist | molnames | randomcmpds | recordnum | recordnums | recordrange | 2dcmpdrecords | 3dcmpdrecords"
Specify what to extract from \fISDFile(s)\fR. Possible values: \fIalldatafields, commondatafields,
datafields, datafieldsbyvalue, datafieldsbyregex, datafieldbylist, datafielduniquebylist, datafieldnotbylist,
molnames, randomcmpds, recordnum, recordnums, recordrange, 2dcmpdrecords, 3dcmpdrecords\fR.
Default value: \fIalldatafields\fR.
.Sp
For \fIalldatafields\fR and \fImolnames\fR mode, only a \s-1CSV/TSV\s0 text file is generated; for all
other modes, however, a \s-1SD\s0 file is generated by default \- you can change the behavior to genereate
text file using \fI\-\-output\fR option.
.Sp
For \fI3DCmpdRecords\fR mode, only those compounds with at least one non-zero value for Z atomic coordinates
are retrieved; however, during retrieval of compounds in \fI2DCmpdRecords\fR mode, all Z atomic coordinates must
be zero.
.IP "\fB\-n, \-\-numofcmpds\fR \fInumber\fR" 4
.IX Item "-n, --numofcmpds number"
Number of compouds to extract during \fIrandomcmpds\fR mode.
.IP "\fB\-\-outdelim\fR \fIcomma | tab | semicolon\fR" 4
.IX Item "--outdelim comma | tab | semicolon"
Delimiter for output \s-1CSV/TSV\s0 text file(s). Possible values: \fIcomma, tab, or semicolon\fR
Default value: \fIcomma\fR
.IP "\fB\-\-output\fR \fI\s-1SD\s0 | text | both\fR" 4
.IX Item "--output SD | text | both"
Type of output files to generate. Possible values: \fI\s-1SD,\s0 text, or both\fR. Default value: \fI\s-1SD\s0\fR. For
\&\fIalldatafields\fR and \fImolnames\fR mode, this option is ingored and only a \s-1CSV/TSV\s0 text file is generated.
.IP "\fB\-o, \-\-overwrite\fR" 4
.IX Item "-o, --overwrite"
Overwrite existing files.
.IP "\fB\-q, \-\-quote\fR \fIyes | no\fR" 4
.IX Item "-q, --quote yes | no"
Put quote around column values in output \s-1CSV/TSV\s0 text file(s). Possible values:
\&\fIyes or no\fR. Default value: \fIyes\fR.
.IP "\fB\-\-record\fR \fIrecnum | recnums | startrecnum,endrecnum\fR" 4
.IX Item "--record recnum | recnums | startrecnum,endrecnum"
Record number, record numbers or range of records to extract during \fIrecordnum\fR, \fIrecordnums\fR
and \fIrecordrange\fR mode. Input value format is: <num>, <num1,num2,...> and <startnum, endnum>
for \fIrecordnum\fR, \fIrecordnums\fR and \fIrecordrange\fR modes recpectively. Default value: none.
.IP "\fB\-\-RegexIgnoreCase\fR \fIyes or no\fR" 4
.IX Item "--RegexIgnoreCase yes or no"
Specify whether to ingnore case during \fIdatafieldsbyregex\fR value of \fB\-m, \-\-mode\fR option.
Possible values: \fIyes or no\fR. Default value: \fIyes\fR.
.IP "\fB\-r, \-\-root\fR \fIrootname\fR" 4
.IX Item "-r, --root rootname"
New file name is generated using the root: <Root>.<Ext>. Default for new file
names: <SDFileName><mode>.<Ext>. The file type determines <Ext> value.
The sdf, csv, and tsv <Ext> values are used for \s-1SD,\s0 comma/semicolon, and tab
delimited text files respectively.This option is ignored for multiple input files.
.IP "\fB\-s, \-\-seed\fR \fInumber\fR" 4
.IX Item "-s, --seed number"
Random number seed used for \fIrandomcmpds\fR mode. Default:123456789.
.IP "\fB\-\-StrDataString\fR \fIyes | no\fR" 4
.IX Item "--StrDataString yes | no"
Specify whether to write out structure data string to \s-1CSV/TSV\s0 text file(s). Possible values:
\&\fIyes or no\fR. Default value: \fIno\fR.
.Sp
The value of \fBStrDataStringDelimiter\fR option is used as a delimiter to join structure
data lines into a structure data string.
.Sp
This option is ignored during generation of \s-1SD\s0 file(s).
.IP "\fB\-\-StrDataStringDelimiter\fR \fItext\fR" 4
.IX Item "--StrDataStringDelimiter text"
Delimiter for joining multiple stucture data lines into a string before writing to \s-1CSV/TSV\s0 text
file(s). Possible values: \fIany alphanumeric text\fR. Default value: \fI|\fR.
.Sp
This option is ignored during generation of \s-1SD\s0 file(s).
.IP "\fB\-\-StrDataStringMode\fR \fIStrOnly | StrAndDataFields\fR" 4
.IX Item "--StrDataStringMode StrOnly | StrAndDataFields"
Specify whether to include \s-1SD\s0 data fields and values along with the structure data into structure
data string before writing it out to \s-1CSV/TSV\s0 text file(s). Possible values: \fIStrOnly or StrAndDataFields\fR.
Default value: \fIStrOnly\fR.
.Sp
The value of \fBStrDataStringDelimiter\fR option is used as a delimiter to join structure
data lines into a structure data string.
.Sp
This option is ignored during generation of \s-1SD\s0 file(s).
.IP "\fB\-\-ValueComparisonMode\fR \fINumeric | Alphanumeric\fR" 4
.IX Item "--ValueComparisonMode Numeric | Alphanumeric"
Specify how to compare data field values during \fIdatafieldsbyvalue\fR mode: Compare
values using either numeric or string ((eq, le, ge) comparison operators. Possible values:
\&\fINumeric or Alphanumeric\fR. Defaule value: \fINumeric\fR.
.IP "\fB\-v, \-\-violations\fR \fInumber\fR" 4
.IX Item "-v, --violations number"
Number of criterion violations allowed for values specified during \fIdatafieldsbyvalue\fR
and \fIdatafieldsbyregex\fR mode. Default value: \fI0\fR.
.IP "\fB\-w, \-\-workingdir\fR \fIdirname\fR" 4
.IX Item "-w, --workingdir dirname"
Location of working directory. Default: current directory.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
To retrieve all data fields from \s-1SD\s0 files and generate \s-1CSV\s0 text files, type:
.PP
.Vb 2
\&    % ExtractFromSDFiles.pl \-o Sample.sdf
\&    % ExtractFromSDFiles.pl \-o *.sdf
.Ve
.PP
To retrieve all data fields from \s-1SD\s0 file and generate \s-1CSV\s0 text files containing
a column with structure data as a string with | as line delimiter, type:
.PP
.Vb 1
\&    % ExtractFromSDFiles.pl \-\-StrDataString Yes \-o Sample.sdf
.Ve
.PP
To retrieve \s-1MOL_ID\s0 data fileld from \s-1SD\s0 file and generate \s-1CSV\s0 text files containing
a column with structure data along with all data fields as a string with | as line
delimiter, type:
.PP
.Vb 3
\&    % ExtractFromSDFiles.pl \-m datafields \-d "Mol_ID" \-\-StrDataString Yes
\&      \-\-StrDataStringMode StrAndDataFields \-\-StrDataStringDelimiter "|"
\&      \-\-output text \-o Sample.sdf
.Ve
.PP
To retrieve common data fields which exists for all the compounds in
a \s-1SD\s0 file and generate a \s-1TSV\s0 text file NewSample.tsv, type:
.PP
.Vb 2
\&    % ExtractFromSDFiles.pl \-m commondatafields \-\-outdelim tab \-r NewSample
\&      \-\-output Text \-o Sample.sdf
.Ve
.PP
To retrieve MolId, ExtReg, and CompoundName data field from a \s-1SD\s0 file and generate a
\&\s-1CSV\s0 text file NewSample.csv, type:
.PP
.Vb 2
\&    % ExtractFromSDFiles.pl \-m datafields \-d "Mol_ID,MolWeight,
\&      CompoundName" \-r NewSample \-\-output Text \-o Sample.sdf
.Ve
.PP
To retrieve compounds from a \s-1SD\s0 which meet a specific set of criteria \- MolWt <= 450,
LogP <= 5 and SumNO < 10 \- from a \s-1SD\s0 file and generate a new \s-1SD\s0 file NewSample.sdf,
type:
.PP
.Vb 2
\&    % ExtractFromSDFiles.pl \-m datafieldsbyvalue \-d "MolWt,450,le,LogP
\&      ,5,le,SumNO,10" \-r NewSample \-o Sample.sdf
.Ve
.PP
To retrive compounds from a \s-1SD\s0 file with a specific set of values for MolID and
generate a new \s-1SD\s0 file NewSample.sdf, type:
.PP
.Vb 2
\&    % ExtractFromSDFiles.pl \-m datafieldbylist \-d "Mol_ID,159,4509,4619"
\&      \-r NewSample \-o Sample.sdf
.Ve
.PP
To retrive compounds from a \s-1SD\s0 file with values for MolID not on a list of specified
values and generate a new \s-1SD\s0 file NewSample.sdf, type:
.PP
.Vb 2
\&    % ExtractFromSDFiles.pl \-m datafieldnotbylist \-d "Mol_ID,159,4509,4619"
\&      \-r NewSample \-o Sample.sdf
.Ve
.PP
To retrive 10 random compounds from a \s-1SD\s0 file and generate a new \s-1SD\s0 file RandomSample.sdf, type:
.PP
.Vb 2
\&    % ExtractFromSDFiles.pl \-m randomcmpds \-n 10 \-r RandomSample
\&      \-o Sample.sdf
.Ve
.PP
To retrive compound record number 10 from a \s-1SD\s0 file and generate a new \s-1SD\s0 file NewSample.sdf, type:
.PP
.Vb 2
\&    % ExtractFromSDFiles.pl \-m recordnum \-\-record 10 \-r NewSample
\&      \-o Sample.sdf
.Ve
.PP
To retrive compound record numbers 10, 20 and 30  from a \s-1SD\s0 file and generate a new \s-1SD\s0 file
NewSample.sdf, type:
.PP
.Vb 2
\&    % ExtractFromSDFiles.pl \-m recordnums \-\-record 10,20,30 \-r NewSample
\&      \-o Sample.sdf
.Ve
.PP
To retrive compound records between 10 to 20 from  \s-1SD\s0 file and generate a new \s-1SD\s0
file NewSample.sdf, type:
.PP
.Vb 2
\&    % ExtractFromSDFiles.pl \-m recordrange \-\-record 10,20 \-r NewSample
\&      \-o Sample.sdf
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Manish Sud <msud@san.rr.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
FilterSDFiles.pl, InfoSDFiles.pl, SplitSDFiles.pl, MergeTextFilesWithSD.pl
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2020 Manish Sud. All rights reserved.
.PP
This file is part of MayaChemTools.
.PP
MayaChemTools is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option)
any later version.
