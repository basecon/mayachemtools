.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PathLengthFingerprints 1"
.TH PathLengthFingerprints 1 "2020-08-27" "perl v5.22.4" "MayaChemTools"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PathLengthFingerprints
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Fingerprints::PathLengthFingerprints;
.PP
use Fingerprints::PathLengthFingerprints qw(:all);
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBPathLengthFingerprints\fR class provides the following methods:
.PP
new, GenerateFingerprints, , GetDescription, SetAtomIdentifierType,
SetAtomicInvariantsToUse, SetFunctionalClassesToUse, SetMaxLength,
SetMinLength, SetNumOfBitsToSetPerPath, SetType,
StringifyPathLengthFingerprints
.PP
\&\fBPathLengthFingerprints\fR is derived from \fBFingerprints\fR class which in turn
is  derived from \fBObjectProperty\fR base class that provides methods not explicitly defined
in \fBPathLengthFingerprints\fR, \fBFingerprints\fR or \fBObjectProperty\fR classes using Perl's
\&\s-1AUTOLOAD\s0 functionality. These methods are generated on-the-fly for a specified object property:
.PP
.Vb 3
\&    Set<PropertyName>(<PropertyValue>);
\&    $PropertyValue = Get<PropertyName>();
\&    Delete<PropertyName>();
.Ve
.PP
The current release of MayaChemTools supports generation of \fBAtomTypesFingerpritns\fR
corresponding to following \fBAtomtomIdentifierTypes\fR:
.PP
.Vb 3
\&    AtomicInvariantsAtomTypes, DREIDINGAtomTypes, EStateAtomTypes,
\&    FunctionalClassAtomTypes, MMFF94AtomTypes, SLogPAtomTypes,
\&    SYBYLAtomTypes, TPSAAtomTypes, UFFAtomTypes
.Ve
.PP
Based on the values specified for \fBType\fR, \fBAtomtomIdentifierTypes\fR, \fBMinPathLength\fR and
\&\fBMaxPathLength\fR, all appropriate atom paths are generated for each atom in the molecule
and collected in a list and the list is filtered to remove any structurally duplicate paths as
indicated by the value of \fBUseUniquePaths\fR.
.PP
For molecules containing rings, atom paths starting from each atom can be traversed in four
different ways:
.PP
.Vb 7
\&    o Atom paths without any rings and sharing of bonds in traversed paths.
\&    o Atom paths containing rings and without any sharing of bonds in
\&      traversed paths
\&    o All possible atom paths without any rings and sharing of bonds in
\&      traversed paths
\&    o All possible atom paths containing rings and with sharing of bonds in
\&      traversed paths.
.Ve
.PP
Atom path traversal is terminated at the last ring atom. For molecules containing no rings,
first two and last two types described above are equivalent.
.PP
\&\fBAllowSharedBonds\fR and \fBAllowRings\fR allow generation of different types of paths
to be used for fingerprints generation.
.PP
The combination of \fBAllowSharedBonds\fR, \fBAllowRings\fR, and \fBUseBondSymbols\fR allows generation of
8 different types of path length fingerprints:
.PP
.Vb 1
\&    AllowSharedBonds AllowRings UseBondSymbols
\&
\&    0                0          1   \- AtomPathsNoCyclesWithBondSymbols
\&    0                1          1   \- AtomPathsWithCyclesWithBondSymbols
\&
\&    1                0          1   \- AllAtomPathsNoCyclesWithBondSymbols
\&    1                1          1   \- AllAtomPathsWithCyclesWithBondSymbols
\&                                      [ DEFAULT ]
\&
\&    0                0          0   \- AtomPathsNoCyclesNoBondSymbols
\&    0                1          0   \- AtomPathsWithCyclesNoBondSymbols
\&
\&    1                0          0   \- AllAtomPathsNoCyclesNoBondSymbols
\&    1                1          0   \- AllAtomPathsWithCyclesNoWithBondSymbols
.Ve
.PP
Additionally, possible values for option \fB\-\-AtomIdentifierType\fR in conjunction with corresponding
specified values for \fBAtomicInvariantsToUse\fR and \fBFunctionalClassesToUse \fR changes the nature
of atom path length strings and the fingerprints.
.PP
For each atom path in the filtered atom paths list, an atom path string is created using value of
\&\fBAtomIdentifierType\fR and specified values to use for a particular atom identifier type.
Value of \fBUseBondSymbols\fR controls whether bond order symbols are used during generation
of atom path string. Atom symbol corresponds to element symbol and characters used to represent
 bond order are: \fI1 \- None; 2 \- '='; 3 \- '#'; 1.5 or aromatic \- ':'; others: bond order value\fR. By default,
bond symbols are included in atom path strings. Exclusion of bond symbols in atom path strings
results in fingerprints which correspond purely to atom paths without considering bonds.
.PP
\&\fBUseUniquePaths\fR controls the removal of structurally duplicate atom path strings are removed
from the list.
.PP
For \fIPathLengthBits\fR value of \fBType\fR, each atom path is hashed to a 32 bit unsigned
integer key using \fBTextUtil::HashCode\fR function. Using the hash key as a seed for a random number
generator, a random integer value between 0 and \fBSize\fR is used to set corresponding bits
in the fingerprint bit-vector string. Value of \fBNumOfBitsToSetPerPaths\fR option controls the number
of time a random number is generated to set corresponding bits.
.PP
For \fI PathLengthCount\fR value of \fBType\fRn, the number of times an atom path appears
is tracked and a fingerprints count-string corresponding to count of atom paths is generated.
.PP
The current release of MayaChemTools generates the following types of path length
fingerprints bit-vector and vector strings:
.PP
.Vb 6
\&    FingerprintsBitVector;PathLengthBits:AtomicInvariantsAtomTypes:MinLeng
\&    th1:MaxLength8;1024;BinaryString;Ascending;001000010011010101011000110
\&    0100010101011000101001011100110001000010001001101000001001001001001000
\&    0010110100000111001001000001001010100100100000000011000000101001011100
\&    0010000001000101010100000100111100110111011011011000000010110111001101
\&    0101100011000000010001000011000010100011101100001000001000100000000...
\&
\&    FingerprintsBitVector;PathLengthBits:AtomicInvariantsAtomTypes:MinLeng
\&    th1:MaxLength8;1024;HexadecimalString;Ascending;48caa1315d82d91122b029
\&    42861c9409a4208182d12015509767bd0867653604481a8b1288000056090583603078
\&    9cedae54e26596889ab121309800900490515224208421502120a0dd9200509723ae89
\&    00024181b86c0122821d4e4880c38620dab280824b455404009f082003d52c212b4e6d
\&    6ea05280140069c780290c43
\&
\&    FingerprintsVector;PathLengthCount:AtomicInvariantsAtomTypes:MinLength
\&    1:MaxLength8;432;NumericalValues;IDsAndValuesPairsString;C.X1.BO1.H3 2
\&    C.X2.BO2.H2 4 C.X2.BO3.H1 14 C.X3.BO3.H1 3 C.X3.BO4 10 F.X1.BO1 1 N.X
\&    2.BO2.H1 1 N.X3.BO3 1 O.X1.BO1.H1 3 O.X1.BO2 2 C.X1.BO1.H3C.X3.BO3.H1
\&    2 C.X2.BO2.H2C.X2.BO2.H2 1 C.X2.BO2.H2C.X3.BO3.H1 4 C.X2.BO2.H2C.X3.BO
\&    4 1 C.X2.BO2.H2N.X3.BO3 1 C.X2.BO3.H1:C.X2.BO3.H1 10 C.X2.BO3.H1:C....
\&
\&    FingerprintsVector;PathLengthCount:DREIDINGAtomTypes:MinLength1:MaxLen
\&    gth8;410;NumericalValues;IDsAndValuesPairsString;C_2 2 C_3 9 C_R 22 F_
\&    1 N_3 1 N_R 1 O_2 2 O_3 3 C_2=O_2 2 C_2C_3 1 C_2C_R 1 C_2N_3 1 C_2O_3
\&    1 C_3C_3 7 C_3C_R 1 C_3N_R 1 C_3O_3 2 C_R:C_R 21 C_R:N_R 2 C_RC_R 2 C
\&    _RF_ 1 C_RN_3 1 C_2C_3C_3 1 C_2C_R:C_R 2 C_2N_3C_R 1 C_3C_2=O_2 1 C_3C
\&    _2O_3 1 C_3C_3C_3 5 C_3C_3C_R 2 C_3C_3N_R 1 C_3C_3O_3 4 C_3C_R:C_R ...
\&
\&    FingerprintsVector;PathLengthCount:EStateAtomTypes:MinLength1:MaxLengt
\&    h8;454;NumericalValues;IDsAndValuesPairsString;aaCH 14 aasC 8 aasN 1 d
\&    O 2 dssC 2 sCH3 2 sF 1 sOH 3 ssCH2 4 ssNH 1 sssCH 3 aaCH:aaCH 10 aaCH:
\&    aasC 8 aasC:aasC 3 aasC:aasN 2 aasCaasC 2 aasCdssC 1 aasCsF 1 aasCssNH
\&    1 aasCsssCH 1 aasNssCH2 1 dO=dssC 2 dssCsOH 1 dssCssCH2 1 dssCssNH 1
\&    sCH3sssCH 2 sOHsssCH 2 ssCH2ssCH2 1 ssCH2sssCH 4 aaCH:aaCH:aaCH 6 a...
\&
\&    FingerprintsVector;PathLengthCount:FunctionalClassAtomTypes:MinLength1
\&    :MaxLength8;404;NumericalValues;IDsAndValuesPairsString;Ar 22 Ar.HBA 1
\&    HBA 2 HBA.HBD 3 HBD 1 Hal 1 NI 1 None 10 Ar.HBA:Ar 2 Ar.HBANone 1 Ar:
\&    Ar 21 ArAr 2 ArHBD 1 ArHal 1 ArNone 2 HBA.HBDNI 1 HBA.HBDNone 2 HBA=NI
\&    1 HBA=None 1 HBDNone 1 NINone 1 NoneNone 7 Ar.HBA:Ar:Ar 2 Ar.HBA:ArAr
\&    1 Ar.HBA:ArNone 1 Ar.HBANoneNone 1 Ar:Ar.HBA:Ar 1 Ar:Ar.HBANone 2 ...
\&
\&    FingerprintsVector;PathLengthCount:MMFF94AtomTypes:MinLength1:MaxLengt
\&    h8;463;NumericalValues;IDsAndValuesPairsString;C5A 2 C5B 2 C=ON 1 CB 1
\&    8 COO 1 CR 9 F 1 N5 1 NC=O 1 O=CN 1 O=CO 1 OC=O 1 OR 2 C5A:C5B 2 C5A:N
\&    5 2 C5ACB 1 C5ACR 1 C5B:C5B 1 C5BC=ON 1 C5BCB 1 C=ON=O=CN 1 C=ONNC=O 1
\&    CB:CB 18 CBF 1 CBNC=O 1 COO=O=CO 1 COOCR 1 COOOC=O 1 CRCR 7 CRN5 1 CR
\&    OR 2 C5A:C5B:C5B 2 C5A:C5BC=ON 1 C5A:C5BCB 1 C5A:N5:C5A 1 C5A:N5CR ...
\&
\&    FingerprintsVector;PathLengthCount:SLogPAtomTypes:MinLength1:MaxLength
\&    8;518;NumericalValues;IDsAndValuesPairsString;C1 5 C10 1 C11 1 C14 1 C
\&    18 14 C20 4 C21 2 C22 1 C5 2 CS 2 F 1 N11 1 N4 1 O10 1 O2 3 O9 1 C10C1
\&    1 C10N11 1 C11C1 2 C11C21 1 C14:C18 2 C14F 1 C18:C18 10 C18:C20 4 C18
\&    :C22 2 C1C5 1 C1CS 4 C20:C20 1 C20:C21 1 C20:N11 1 C20C20 2 C21:C21 1
\&    C21:N11 1 C21C5 1 C22N4 1 C5=O10 1 C5=O9 1 C5N4 1 C5O2 1 CSO2 2 C10...
\&
\&    FingerprintsVector;PathLengthCount:SYBYLAtomTypes:MinLength1:MaxLength
\&    8;412;NumericalValues;IDsAndValuesPairsString;C.2 2 C.3 9 C.ar 22 F 1
\&    N.am 1 N.ar 1 O.2 1 O.3 2 O.co2 2 C.2=O.2 1 C.2=O.co2 1 C.2C.3 1 C.2C.
\&    ar 1 C.2N.am 1 C.2O.co2 1 C.3C.3 7 C.3C.ar 1 C.3N.ar 1 C.3O.3 2 C.ar:C
\&    .ar 21 C.ar:N.ar 2 C.arC.ar 2 C.arF 1 C.arN.am 1 C.2C.3C.3 1 C.2C.ar:C
\&    .ar 2 C.2N.amC.ar 1 C.3C.2=O.co2 1 C.3C.2O.co2 1 C.3C.3C.3 5 C.3C.3...
\&
\&    FingerprintsVector;PathLengthCount:TPSAAtomTypes:MinLength1:MaxLength8
\&    ;331;NumericalValues;IDsAndValuesPairsString;N21 1 N7 1 None 34 O3 2 O
\&    4 3 N21:None 2 N21None 1 N7None 2 None:None 21 None=O3 2 NoneNone 13 N
\&    oneO4 3 N21:None:None 2 N21:NoneNone 2 N21NoneNone 1 N7None:None 2 N7N
\&    one=O3 1 N7NoneNone 1 None:N21:None 1 None:N21None 2 None:None:None 20
\&    None:NoneNone 12 NoneN7None 1 NoneNone=O3 2 NoneNoneNone 8 NoneNon...
\&
\&    FingerprintsVector;PathLengthCount:UFFAtomTypes:MinLength1:MaxLength8;
\&    410;NumericalValues;IDsAndValuesPairsString;C_2 2 C_3 9 C_R 22 F_ 1 N_
\&    3 1 N_R 1 O_2 2 O_3 3 C_2=O_2 2 C_2C_3 1 C_2C_R 1 C_2N_3 1 C_2O_3 1 C_
\&    3C_3 7 C_3C_R 1 C_3N_R 1 C_3O_3 2 C_R:C_R 21 C_R:N_R 2 C_RC_R 2 C_RF_
\&    1 C_RN_3 1 C_2C_3C_3 1 C_2C_R:C_R 2 C_2N_3C_R 1 C_3C_2=O_2 1 C_3C_2O_3
\&    1 C_3C_3C_3 5 C_3C_3C_R 2 C_3C_3N_R 1 C_3C_3O_3 4 C_3C_R:C_R 1 C_3...
.Ve
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 2
\&    $NewPathLengthFingerprints = new PathLengthFingerprints(
\&                                                   %NamesAndValues);
.Ve
.Sp
Using specified \fIPathLengthFingerprints\fR property names and values hash, \fBnew\fR method creates a new object
and returns a reference to newly created \fBPathLengthFingerprints\fR object. By default, the following properties are
initialized:
.Sp
.Vb 10
\&    Molecule = \*(Aq\*(Aq;
\&    Type = \*(Aq\*(Aq
\&    Size = 1024
\&    MinSize = 32
\&    MaxSize = 2**32
\&    NumOfBitsToSetPerPath = 1
\&    MinLength = 1
\&    MaxLength = 8
\&    AllowSharedBonds = 1
\&    AllowRings = 1
\&    UseBondSymbols = 1
\&    UseUniquePaths = \*(Aq\*(Aq
\&    AtomIdentifierType = \*(Aq\*(Aq
\&    SetAtomicInvariantsToUse = [\*(AqAS\*(Aq]
\&    FunctionalClassesToUse = [\*(AqHBD\*(Aq, \*(AqHBA\*(Aq, \*(AqPI\*(Aq, \*(AqNI\*(Aq, \*(AqAr\*(Aq, \*(AqHal\*(Aq]
.Ve
.Sp
Examples:
.Sp
.Vb 5
\&    $PathLengthFingerprints = new PathLengthFingerprints(
\&                              \*(AqMolecule\*(Aq => $Molecule,
\&                               \*(AqType\*(Aq => \*(AqPathLengthBits\*(Aq,
\&                               \*(AqAtomIdentifierType\*(Aq =
\&                                              \*(AqAtomicInvariantsAtomTypes\*(Aq);
\&
\&    $PathLengthFingerprints = new PathLengthFingerprints(
\&                               \*(AqMolecule\*(Aq => $Molecule,
\&                               \*(AqType\*(Aq => \*(AqPathLengthBits\*(Aq,
\&                               \*(AqSize\*(Aq => 1024,
\&                               \*(AqMinLength\*(Aq => 1,
\&                               \*(AqMaxLength\*(Aq => 8,
\&                               \*(AqAllowRings\*(Aq => 1,
\&                               \*(AqAllowSharedBonds\*(Aq => 1,
\&                               \*(AqUseBondSymbols\*(Aq => 1,
\&                               \*(AqUseUniquePaths\*(Aq => 1,
\&                               \*(AqAtomIdentifierType\*(Aq =
\&                                              \*(AqAtomicInvariantsAtomTypes\*(Aq,
\&                               \*(AqAtomicInvariantsToUse\*(Aq => [\*(AqAS\*(Aq]);
\&
\&    $PathLengthFingerprints = new PathLengthFingerprints(
\&                               \*(AqMolecule\*(Aq => $Molecule,
\&                               \*(AqType\*(Aq => \*(AqPathLengthCount\*(Aq,
\&                               \*(AqMinLength\*(Aq => 1,
\&                               \*(AqMaxLength\*(Aq => 8,
\&                               \*(AqAllowRings\*(Aq => 1,
\&                               \*(AqAllowSharedBonds\*(Aq => 1,
\&                               \*(AqUseBondSymbols\*(Aq => 1,
\&                               \*(AqUseUniquePaths\*(Aq => 1,
\&                               \*(AqAtomIdentifierType\*(Aq =>
\&                                              \*(AqAtomicInvariantsAtomTypes\*(Aq,
\&                               \*(AqAtomicInvariantsToUse\*(Aq => [\*(AqAS\*(Aq]);
\&
\&    $PathLengthFingerprints = new PathLengthFingerprints(
\&                              \*(AqMolecule\*(Aq => $Molecule,
\&                               \*(AqType\*(Aq => \*(AqPathLengthBits\*(Aq,
\&                               \*(AqAtomIdentifierType\*(Aq =
\&                                              \*(AqSLogPAtomTypes\*(Aq);
\&
\&    $PathLengthFingerprints = new PathLengthFingerprints(
\&                              \*(AqMolecule\*(Aq => $Molecule,
\&                               \*(AqType\*(Aq => \*(AqPathLengthCount\*(Aq,
\&                               \*(AqAtomIdentifierType\*(Aq =
\&                                              \*(AqSYBYLAtomTypes\*(Aq);
\&
\&    $PathLengthFingerprints = new PathLengthFingerprints(
\&                               \*(AqMolecule\*(Aq => $Molecule,
\&                               \*(AqType\*(Aq => \*(AqPathLengthBits\*(Aq,
\&                               \*(AqAtomIdentifierType\*(Aq =
\&                                              \*(AqFunctionalClassAtomTypes\*(Aq,
\&                               \*(AqFunctionalClassesToUse\*(Aq => [\*(AqHBD\*(Aq, \*(AqHBA\*(Aq, \*(AqAr\*(Aq]);
\&
\&    $PathLengthFingerprints\->GenerateFingerprints();
\&    print "$PathLengthFingerprints\en";
.Ve
.IP "\fBGetDescription\fR" 4
.IX Item "GetDescription"
.Vb 1
\&    $Description = $PathLengthFingerprints\->GetDescription();
.Ve
.Sp
Returns a string containing description of path length fingerprints.
.IP "\fBGenerateFingerprints\fR" 4
.IX Item "GenerateFingerprints"
.Vb 1
\&    $PathLengthFingerprints\->GenerateFingerprints();
.Ve
.Sp
Generates path length fingerprints and returns \fIPathLengthFingerprints\fR.
.IP "\fBSetMaxLength\fR" 4
.IX Item "SetMaxLength"
.Vb 1
\&    $PathLengthFingerprints\->SetMaxLength($Length);
.Ve
.Sp
Sets maximum value of atom path length to be used during atom path length fingerprints
generation and returns \fIPathLengthFingerprints\fR
.IP "\fBSetAtomIdentifierType\fR" 4
.IX Item "SetAtomIdentifierType"
.Vb 1
\&    $PathLengthFingerprints\->SetAtomIdentifierType();
.Ve
.Sp
Sets atom \fIIdentifierType\fR to use during path length fingerprints generation and
returns \fIPathLengthFingerprints\fR.
.Sp
Possible values: \fIAtomicInvariantsAtomTypes, DREIDINGAtomTypes, EStateAtomTypes,
FunctionalClassAtomTypes, MMFF94AtomTypes, SLogPAtomTypes, SYBYLAtomTypes,
TPSAAtomTypes, UFFAtomTypes\fR.
.IP "\fBSetAtomicInvariantsToUse\fR" 4
.IX Item "SetAtomicInvariantsToUse"
.Vb 2
\&    $PathLengthFingerprints\->SetAtomicInvariantsToUse($ValuesRef);
\&    $PathLengthFingerprints\->SetAtomicInvariantsToUse(@Values);
.Ve
.Sp
Sets atomic invariants to use during \fIAtomicInvariantsAtomTypes\fR value of \fIAtomIdentifierType\fR
for path length fingerprints generation and returns \fIPathLengthFingerprints\fR.
.Sp
Possible values for atomic invariants are: \fI\s-1AS, X, BO,  LBO, SB, DB, TB,
H,\s0 Ar, \s-1RA, FC, MN, SM\s0\fR. Default value: \fI\s-1AS\s0\fR.
.Sp
The atomic invariants abbreviations correspond to:
.Sp
.Vb 1
\&    AS = Atom symbol corresponding to element symbol
\&
\&    X<n>   = Number of non\-hydrogen atom neighbors or heavy atoms
\&    BO<n> = Sum of bond orders to non\-hydrogen atom neighbors or heavy atoms
\&    LBO<n> = Largest bond order of non\-hydrogen atom neighbors or heavy atoms
\&    SB<n> = Number of single bonds to non\-hydrogen atom neighbors or heavy atoms
\&    DB<n> = Number of double bonds to non\-hydrogen atom neighbors or heavy atoms
\&    TB<n> = Number of triple bonds to non\-hydrogen atom neighbors or heavy atoms
\&    H<n>   = Number of implicit and explicit hydrogens for atom
\&    Ar     = Aromatic annotation indicating whether atom is aromatic
\&    RA     = Ring atom annotation indicating whether atom is a ring
\&    FC<+n/\-n> = Formal charge assigned to atom
\&    MN<n> = Mass number indicating isotope other than most abundant isotope
\&    SM<n> = Spin multiplicity of atom. Possible values: 1 (singlet), 2 (doublet) or
\&            3 (triplet)
.Ve
.Sp
Atom type generated by AtomTypes::AtomicInvariantsAtomTypes class corresponds to:
.Sp
.Vb 1
\&    AS.X<n>.BO<n>.LBO<n>.<SB><n>.<DB><n>.<TB><n>.H<n>.Ar.RA.FC<+n/\-n>.MN<n>.SM<n>
.Ve
.Sp
Except for \s-1AS\s0 which is a required atomic invariant in atom types, all other atomic invariants are
optional. Atom type specification doesn't include atomic invariants with zero or undefined values.
.Sp
In addition to usage of abbreviations for specifying atomic invariants, the following descriptive words
are also allowed:
.Sp
.Vb 12
\&    X : NumOfNonHydrogenAtomNeighbors or NumOfHeavyAtomNeighbors
\&    BO : SumOfBondOrdersToNonHydrogenAtoms or SumOfBondOrdersToHeavyAtoms
\&    LBO : LargestBondOrderToNonHydrogenAtoms or LargestBondOrderToHeavyAtoms
\&    SB :  NumOfSingleBondsToNonHydrogenAtoms or NumOfSingleBondsToHeavyAtoms
\&    DB : NumOfDoubleBondsToNonHydrogenAtoms or NumOfDoubleBondsToHeavyAtoms
\&    TB : NumOfTripleBondsToNonHydrogenAtoms or NumOfTripleBondsToHeavyAtoms
\&    H :  NumOfImplicitAndExplicitHydrogens
\&    Ar : Aromatic
\&    RA : RingAtom
\&    FC : FormalCharge
\&    MN : MassNumber
\&    SM : SpinMultiplicity
.Ve
.Sp
\&\fIAtomTypes::AtomicInvariantsAtomTypes\fR module is used to assign atomic invariant
atom types.
.IP "\fBSetFunctionalClassesToUse\fR" 4
.IX Item "SetFunctionalClassesToUse"
.Vb 2
\&    $PathLengthFingerprints\->SetFunctionalClassesToUse($ValuesRef);
\&    $PathLengthFingerprints\->SetFunctionalClassesToUse(@Values);
.Ve
.Sp
Sets functional classes invariants to use during \fIFunctionalClassAtomTypes\fR value of \fIAtomIdentifierType\fR
for path length fingerprints generation and returns \fIPathLengthFingerprints\fR.
.Sp
Possible values for atom functional classes are: \fIAr, \s-1CA, H, HBA, HBD,\s0 Hal, \s-1NI, PI, RA\s0\fR.
Default value [ Ref 24 ]: \fI\s-1HBD,HBA,PI,NI\s0,Ar,Hal\fR.
.Sp
The functional class abbreviations correspond to:
.Sp
.Vb 9
\&    HBD: HydrogenBondDonor
\&    HBA: HydrogenBondAcceptor
\&    PI :  PositivelyIonizable
\&    NI : NegativelyIonizable
\&    Ar : Aromatic
\&    Hal : Halogen
\&    H : Hydrophobic
\&    RA : RingAtom
\&    CA : ChainAtom
\&
\& Functional class atom type specification for an atom corresponds to:
\&
\&    Ar.CA.H.HBA.HBD.Hal.NI.PI.RA or None
.Ve
.Sp
\&\fIAtomTypes::FunctionalClassAtomTypes\fR module is used to assign functional class atom
types. It uses following definitions [ Ref 60\-61, Ref 65\-66 ]:
.Sp
.Vb 4
\&    HydrogenBondDonor: NH, NH2, OH
\&    HydrogenBondAcceptor: N[!H], O
\&    PositivelyIonizable: +, NH2
\&    NegativelyIonizable: \-, C(=O)OH, S(=O)OH, P(=O)OH
.Ve
.IP "\fBSetMinLength\fR" 4
.IX Item "SetMinLength"
.Vb 1
\&    $PathLengthFingerprints\->SetMinLength($Length);
.Ve
.Sp
Sets minimum value of atom path length to be used during atom path length fingerprints
generation and returns \fIPathLengthFingerprints\fR.
.IP "\fBSetMaxLength\fR" 4
.IX Item "SetMaxLength"
.Vb 1
\&    $PathLengthFingerprints\->SetMaxLength($Length);
.Ve
.Sp
Sets maximum value of atom path length to be used during atom path length fingerprints
generation and returns \fIPathLengthFingerprints\fR.
.IP "\fBSetNumOfBitsToSetPerPath\fR" 4
.IX Item "SetNumOfBitsToSetPerPath"
.Vb 1
\&    $PathLengthFingerprints\->SetNumOfBitsToSetPerPath($NumOfBits);
.Ve
.Sp
Sets number of bits to set for each path during \fIPathLengthBits\fR \fBType \fR during path length fingerprints
generation and returns \fIPathLengthFingerprints\fR.
.IP "\fBSetType\fR" 4
.IX Item "SetType"
.Vb 1
\&    $PathLengthFingerprints\->SetType($Type);
.Ve
.Sp
Sets type of path length fingerprints and returns \fIPathLengthFingerprints\fR. Possible values:
\&\fIPathLengthBits or PathLengthCount\fR.
.IP "\fBStringifyPathLengthFingerprints\fR" 4
.IX Item "StringifyPathLengthFingerprints"
.Vb 1
\&    $String = $PathLengthFingerprints\->StringifyPathLengthFingerprints();
.Ve
.Sp
Returns a string containing information about \fIPathLengthFingerprints\fR object.
.SH "AUTHOR"
.IX Header "AUTHOR"
Manish Sud <msud@san.rr.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Fingerprints.pm, FingerprintsStringUtil.pm, AtomNeighborhoodsFingerprints.pm,
AtomTypesFingerprints.pm, EStateIndiciesFingerprints.pm, ExtendedConnectivityFingerprints.pm,
MACCSKeys.pm, TopologicalAtomPairsFingerprints.pm, TopologicalAtomTripletsFingerprints.pm,
TopologicalAtomTorsionsFingerprints.pm, TopologicalPharmacophoreAtomPairsFingerprints.pm,
TopologicalPharmacophoreAtomTripletsFingerprints.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2020 Manish Sud. All rights reserved.
.PP
This file is part of MayaChemTools.
.PP
MayaChemTools is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option)
any later version.
