.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "StatisticsUtil 1"
.TH StatisticsUtil 1 "2020-08-27" "perl v5.22.4" "MayaChemTools"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
StatisticsUtil
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use StatisticsUtil;
.PP
use Statistics qw(:all);
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBStatisticsUtil\fR module provides the following functions:
.PP
Average, AverageDeviation, Correlation, Covariance, Euclidean, Factorial,
FactorialDivison, Frequency, GeometricMean, HarmonicMean, KLargest, KSmallest,
Kurtosis, Maximum, Mean, Median, Minimum, Mode, PearsonCorrelation, Permutations,
Product, RSquare, Range, Skewness, StandardDeviation, StandardDeviationN,
StandardError, StandardScores, StandardScoresN, Standardize, Sum, SumOfSquares,
TrimMean, Variance, VarianceN
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "\fBAverage\fR" 4
.IX Item "Average"
.Vb 1
\&    $Value = Average(\e@DataArray);
.Ve
.Sp
Computes the mean of an array of numbers: \s-1SUM\s0( x[i] ) / n
.IP "\fBAverageDeviation\fR" 4
.IX Item "AverageDeviation"
.Vb 1
\&    $Value = AverageDeviation(\e@DataArray);
.Ve
.Sp
Computes the average of the absolute deviation of an array of numbers: \s-1SUM\s0( \s-1ABS\s0(x[i] \- Xmean) ) / n
.IP "\fBCorrelation\fR" 4
.IX Item "Correlation"
.Vb 1
\&    $Value = Correlation(\e@XDataArray, \e@YDataArray);
.Ve
.Sp
Computes the Pearson correlation coefficient between two arrays of numbers:
\&\s-1SUM\s0( (x[i] \- Xmean)(y[i] \- Ymean) ) / \s-1SQRT\s0( \s-1SUM\s0( (x[i] \- Xmean)^2 )(\s-1SUM\s0( (y[i] \- Ymean)^2 ))   )
.IP "\fBEuclidean\fR" 4
.IX Item "Euclidean"
.Vb 1
\&    $Return = Euclidean(\e@DataArray);
.Ve
.Sp
Computes the euclidean distance of an array of numbers: \s-1SQRT\s0( \s-1SUM\s0( x[i] ** 2) )
.IP "\fBCovariance\fR" 4
.IX Item "Covariance"
.Vb 1
\&    $Value = Covariance(\e@XDataArray, \e@YDataArray);
.Ve
.Sp
Computes the covariance between two arrays of numbers: \s-1SUM\s0( (x[i] \- Xmean) (y[i] \- Ymean) ) / n
.IP "\fBFactorial\fR" 4
.IX Item "Factorial"
.Vb 1
\&    $Value = Factorial($Num);
.Ve
.Sp
Computes the factorial of a positive integer.
.IP "\fBFactorialDivison\fR" 4
.IX Item "FactorialDivison"
.Vb 1
\&    $Value = FactorialDivision($Numerator, $Denominator);
.Ve
.Sp
Compute the factorial divison of two positive integers.
.IP "\fBFrequency\fR" 4
.IX Item "Frequency"
.Vb 2
\&    %FrequencyValues = Frequency(\e@DataArray, [$NumOfBins]);
\&    %FrequencyValues = Frequency(\e@DataArray, [\e@BinRange]);
.Ve
.Sp
A hash array is returned with keys and values representing range and frequency values, respectively.
The frequency value for a specific key corresponds to all the values which are greater than
the previous key and less than or equal to the current key. A key value representing maximum value is
added for generating frequency distribution for specific number of bins, and whenever the maximum
array value is greater than the maximum specified in bin range, it is also added to bin range.
.IP "\fBGeometricMean\fR" 4
.IX Item "GeometricMean"
.Vb 1
\&    $Value = GeometricMean(\e@DataArray);
.Ve
.Sp
Computes the geometric mean of an array of numbers: NthROOT( \s-1PRODUCT\s0(x[i]) )
.IP "\fBHarmonicMean\fR" 4
.IX Item "HarmonicMean"
.Vb 1
\&    $Value = HarmonicMean(\e@DataArray);
.Ve
.Sp
Computes the harmonic mean of an array of numbers: 1 / ( \s-1SUM\s0(1/x[i]) / n )
.IP "\fBKLargest\fR" 4
.IX Item "KLargest"
.Vb 1
\&    $Value = KLargest(\e@DataArray, $KthNumber);
.Ve
.Sp
Returns the k\-largest value from an array of numbers.
.IP "\fBKSmallest\fR" 4
.IX Item "KSmallest"
.Vb 1
\&    $Value = KSmallest(\e@DataArray, $KthNumber);
.Ve
.Sp
Returns the k\-smallest value from an array of numbers.
.IP "\fBKurtosis\fR" 4
.IX Item "Kurtosis"
.Vb 1
\&    $Value = Kurtosis(\e@DataArray);
.Ve
.Sp
Computes the kurtosis of an array of numbers:
[ {n(n + 1)/(n \- 1)(n \- 2)(n \- 3)}  SUM{ ((x[i] \- Xmean)/STDDEV)^4 } ] \- {3((n \- 1)^2)}/{(n \- 2)(n\-3)}
.IP "\fBMaximum\fR" 4
.IX Item "Maximum"
.Vb 1
\&    $Value = Maximum(\e@DataArray);
.Ve
.Sp
Returns the largest value from an array of numbers.
.IP "\fBMinimum\fR" 4
.IX Item "Minimum"
.Vb 1
\&    $Value = Minimum(\e@DataArray);
.Ve
.Sp
Returns the smallest value from an array of numbers.
.IP "\fBMean\fR" 4
.IX Item "Mean"
.Vb 1
\&    $Value = Mean(\e@DataArray);
.Ve
.Sp
Computes the mean of an array of numbers: \s-1SUM\s0( x[i] ) / n
.IP "\fBMedian\fR" 4
.IX Item "Median"
.Vb 1
\&    $Value = Median(\e@DataArray);
.Ve
.Sp
Computes the median value of an array of numbers. For an even number array, it's
the average of two middle values.
.Sp
For even values of n: Xsorted[(n \- 1)/2 + 1]
For odd values of n: (Xsorted[n/2] + Xsorted[n/2 + 1])/2
.IP "\fBMode\fR" 4
.IX Item "Mode"
.Vb 1
\&    $Value = Mode(\e@DataArray);
.Ve
.Sp
Returns the most frequently occuring value in an array of numbers.
.IP "\fBPearsonCorrelation\fR" 4
.IX Item "PearsonCorrelation"
.Vb 1
\&    $Value = Correlation(\e@XDataArray, \e@YDataArray);
.Ve
.Sp
Computes the Pearson correlation coefficient between two arrays of numbers:
\&\s-1SUM\s0( (x[i] \- Xmean)(y[i] \- Ymean) ) / \s-1SQRT\s0( \s-1SUM\s0( (x[i] \- Xmean)^2 )(\s-1SUM\s0( (y[i] \- Ymean)^2 ))   )
.IP "\fBPermutations\fR" 4
.IX Item "Permutations"
.Vb 1
\&    $PermutationsRef = Permutations(@DataToPermute);
.Ve
.Sp
Generate all possible permuations or a specific permutations of items in an array
and return a reference to an array containing array references to generated permuations.
.Sp
This alogrithm is based on the example provided by Mark Jason-Dominus, and is available
at \s-1CPAN\s0 as mjd_permute standalone script.
.IP "\fBProduct\fR" 4
.IX Item "Product"
.Vb 1
\&    $Value = Product(\e@DataArray);
.Ve
.Sp
Compute the product of an array of numbers.
.IP "\fBRange\fR" 4
.IX Item "Range"
.Vb 1
\&    ($Smallest, $Largest) = Range(\e@DataArray);
.Ve
.Sp
Return the smallest and largest values from an array of numbers.
.IP "\fBRSquare\fR" 4
.IX Item "RSquare"
.Vb 1
\&    $Value = RSquare(\e@XDataArray, \e@YDataArray);
.Ve
.Sp
Computes square of the Pearson correlation coefficient between two arrays of numbers.
.IP "\fBSkewness\fR" 4
.IX Item "Skewness"
.Vb 1
\&    $Value = Skewness(\e@DataArray);
.Ve
.Sp
Computes the skewness of an array of numbers:
{n/(n \- 1)(n \- 2)} SUM{ ((x[i] \- Xmean)/STDDEV)^3 }
.IP "\fBStandardDeviation\fR" 4
.IX Item "StandardDeviation"
.Vb 1
\&    $Value = StandardDeviation(\e@DataArray);
.Ve
.Sp
Computes the standard deviation of an array of numbers.
\&\s-1SQRT \s0( \s-1SUM\s0( (x[i] \- mean)^2 ) / (n \- 1) )
.IP "\fBStandardDeviationN\fR" 4
.IX Item "StandardDeviationN"
.Vb 1
\&    $Value = StandardDeviationN(\e@DataArray);
.Ve
.Sp
Computes the standard deviation of an array of numbers representing entire population:
\&\s-1SQRT \s0( \s-1SUM\s0( (x[i] \- mean)^2 ) / n )
.IP "\fBStandardError\fR" 4
.IX Item "StandardError"
.Vb 1
\&    $Value = StandardError($StandardDeviation, $Count);
.Ve
.Sp
Computes the standard error using standard deviation and sample size.
.IP "\fBStandardize\fR" 4
.IX Item "Standardize"
.Vb 1
\&    $Value = Standardize($Value, $Mean, $StandardDeviation);
.Ve
.Sp
Standardizes the value using mean and standard deviation.
.IP "\fBStandardScores\fR" 4
.IX Item "StandardScores"
.Vb 1
\&    @Values = StandardScores(\e@DataArray);
.Ve
.Sp
Computes the standard deviation above the mean for an array of numbers:
(x[i] \- mean) / (n \- 1)
.IP "\fBStandardScoresN\fR" 4
.IX Item "StandardScoresN"
.Vb 1
\&    @Values = StandardScoresN(\e@DataArray);
.Ve
.Sp
Computes the standard deviation above the mean for an array of numbers representing entire population:
(x[i] \- mean) / n
.IP "\fBSum\fR" 4
.IX Item "Sum"
.Vb 1
\&    $Value = Sum(\e@DataArray);
.Ve
.Sp
Compute the sum of an array of numbers.
.IP "\fBSumOfSquares\fR" 4
.IX Item "SumOfSquares"
.Vb 1
\&    $Value = SumOfSquares(\e@DataArray);
.Ve
.Sp
Computes the sum of an array of numbers.
.IP "\fBTrimMean\fR" 4
.IX Item "TrimMean"
.Vb 1
\&    $Value = TrimMean(\e@DataArray, $FractionToExclude));
.Ve
.Sp
Computes the mean of an array of numbers by excluding a fraction of
numbers from the top and bottom of the data set.
.IP "\fBVariance\fR" 4
.IX Item "Variance"
.Vb 1
\&    $Value = Variance(\e@DataArray);
.Ve
.Sp
Computes the variance of an array of numbers: \s-1SUM\s0( (x[i] \- Xmean)^2  / (n \- 1) )
.IP "\fBVarianceN\fR" 4
.IX Item "VarianceN"
.Vb 1
\&    $Value = Variance(\e@DataArray);
.Ve
.Sp
Compute the variance of an array of numbers representing entire population:
\&\s-1SUM\s0( (x[i] \- Xmean)^2  / n )
.SH "AUTHOR"
.IX Header "AUTHOR"
Manish Sud <msud@san.rr.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Constants.pm, ConversionsUtil.pm, MathUtil.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2020 Manish Sud. All rights reserved.
.PP
This file is part of MayaChemTools.
.PP
MayaChemTools is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option)
any later version.
