.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "BitVector 1"
.TH BitVector 1 "2020-08-27" "perl v5.22.4" "MayaChemTools"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
BitVector
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use BitVector;
.PP
use BitVector ();
.PP
use BitVector qw(:all);
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBBitVector\fR class provides the following methods:
.PP
new, ClearAllBits, ClearBit, ClearBits, ClearBitsRange, Copy, FlipAllBits,
FlipBit, FlipBits, FlipBitsRange, GetBit, GetBitsAsBinaryString,
GetBitsAsDecimalString, GetBitsAsHexadecimalString, GetBitsAsOctalString,
GetBitsAsRawBinaryString, GetDensityOfClearBits, GetDensityOfSetBits,
GetNumOfClearBits, GetNumOfSetBits, GetSize, IsBitClear, IsBitSet, IsBitVector,
NewFromBinaryString, NewFromDecimalString, NewFromHexadecimalString,
NewFromOctalString, NewFromRawBinaryString, Reverse, SetAllBits, SetBit,
SetBitValue, SetBitValueBitOrder, SetBitValuePrintFormat, SetBits,
SetBitsAsBinaryString, SetBitsAsDecimalString, SetBitsAsHexadecimalString,
SetBitsAsOctalString, SetBitsAsRawBinaryString, SetBitsRange, StringifyBitVector
.PP
The following methods can also be used as functions:
.PP
IsBitVector, NewFromBinaryString, NewFromDecimalString, NewFromHexadecimalString,
NewFromOctalString, NewFromRawBinaryString
.PP
The following operators are overloaded:
.PP
.Vb 1
\&    "" & | ^ ~ == !=
.Ve
.PP
Internally, bits are stored in ascending order using Perl vec function. Regardless
of machine order, big-endian or little-endian, vec function always considers first
string byte as the lowest byte and first bit within each byte as the lowest bit.
.PP
Things to keep in mind:
.PP
.Vb 5
\&    o Bit numbers range from 0 to (Size \- 1).
\&    o Bit data retieval methods provide options to data in ascending or
\&      descending bit order. Default is ascending bit order.
\&    o Stringyfy method provides an option to print data in ascending or
\&      descending bit order. Default is ascending bit order.
.Ve
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.IP "\fBnew\fR" 4
.IX Item "new"
.Vb 1
\&    $NewBitVector = new BitVector($Size);
.Ve
.Sp
Create a new \fIBitVector\fR object of size \fISize\fR and return  newly created
\&\fBBitVector\fR. Bit numbers range from 0 to 1 less than \fISize\fR.
.IP "\fBClearAllBits\fR" 4
.IX Item "ClearAllBits"
.Vb 1
\&    $BitVector\->ClearAllBits();
.Ve
.Sp
Set all bit values to 0 in \fIBitVector\fR object and return \fIBitVector\fR.
.IP "\fBClearBit\fR" 4
.IX Item "ClearBit"
.Vb 1
\&    $BitVector\->ClearBit($BitNum);
.Ve
.Sp
Set specified bit number \fIBitNum\fR to 0 in \fIBitVector\fR object and return \fIBitVector\fR.
.IP "\fBClearBits\fR" 4
.IX Item "ClearBits"
.Vb 1
\&    $BitVector\->ClearBits(@BitNums);
.Ve
.Sp
Set specified bit numbers \fIBitNums\fR to 0 in \fIBitVector\fR object and return \fIBitVector\fR.
.IP "\fBClearBitsRange\fR" 4
.IX Item "ClearBitsRange"
.Vb 1
\&    $BitVector\->ClearBitsRange($MinBitNum, $MaxBitNum);
.Ve
.Sp
Set specified bit numbers between \fIMinBitNum\fR and \fIMaxBitNum\fR to 0 in \fIBitVector\fR
object and return \fIBitVector\fR.
.IP "\fBCopy\fR" 4
.IX Item "Copy"
.Vb 1
\&    $NewBitVector = $BitVector\->Copy();
.Ve
.Sp
Copy \fIBitVector\fR and its associated data to a new \fBBitVector\fR and return a new
\&\fBBitVector\fR.
.IP "\fBFlipAllBits\fR" 4
.IX Item "FlipAllBits"
.Vb 1
\&    $BitVector\->FlipAllBits();
.Ve
.Sp
Flip values of all bits in \fIBitVector\fR and its associated data to a new \fBBitVector\fR and return
\&\fIBitVector\fR.
.IP "\fBFlipBit\fR" 4
.IX Item "FlipBit"
.Vb 1
\&    $BitVector\->FlipBit($BitNum);
.Ve
.Sp
Flip value of specified \fIBitNum\fR of in \fIBitVector\fR and return \fIBitVector\fR.
.IP "\fBFlipBits\fR" 4
.IX Item "FlipBits"
.Vb 1
\&    $BitVector\->FlipBits(@BitNums);
.Ve
.Sp
Flip values of specified bit numbers \fIBitNums\fR in \fIBitVector\fR object and return \fIBitVector\fR.
.IP "\fBFlipBitsRange\fR" 4
.IX Item "FlipBitsRange"
.Vb 1
\&    $BitVector\->FlipBitsRange($MinBitNum, $MaxBitNum);
.Ve
.Sp
Flip values of specified bit numbers between \fIMinBitNum\fR and \fIMaxBitNum\fR in \fIBitVector\fR
object and return \fIBitVector\fR.
.IP "\fBGetBit\fR" 4
.IX Item "GetBit"
.Vb 1
\&    $BitValue = $BitVector\->GetBit($BitNum);
.Ve
.Sp
Returns value of bit number \fIBitNum\fR in \fIBitVector\fR object.
.IP "\fBGetBitsAsBinaryString\fR" 4
.IX Item "GetBitsAsBinaryString"
.Vb 1
\&    $BitString = $BitVector\->GetBitsAsBinaryString([$BitOrder]);
.Ve
.Sp
Returns values of bits in \fIBitVector\fR as an ascii bit string containing 0s and 1s.
.Sp
Default \fIBitOrder\fR is \fIAscending\fR bit order which corresponds to first bit in each
byte as the loweset bit as opposed to the higest bit.
.IP "\fBGetBitsAsDecimalString\fR" 4
.IX Item "GetBitsAsDecimalString"
.Vb 1
\&    $BitString = $BitVector\->GetBitsAsDecimalString([$BitOrder]);
.Ve
.Sp
Returns values of bits in \fIBitVector\fR as a decimal bit string containing values from 0 to
9.
.Sp
Default \fIBitOrder\fR is \fIAscending\fR bit order which corresponds to first bit in each
byte as the loweset bit as opposed to the higest bit.
.IP "\fBGetBitsAsHexadecimalString\fR" 4
.IX Item "GetBitsAsHexadecimalString"
.Vb 1
\&    $BitString = $BitVector\->GetBitsAsHexadecimalString([$BitOrder]);
.Ve
.Sp
Returns values of bits in \fIBitVector\fR as a hexadecimal bit string containing values from 0 to 9
and a to f.
.Sp
Default \fIBitOrder\fR is \fIAscending\fR bit order which corresponds to first bit in each
byte as the loweset bit as opposed to the higest bit.
.IP "\fBGetBitsAsOctalString\fR" 4
.IX Item "GetBitsAsOctalString"
.Vb 1
\&    $BitString = $BitVector\->GetBitsAsOctalString([$BitOrder]);
.Ve
.Sp
Returns values of bits in \fIBitVector\fR as an octal bit string containing values form 0 to
7.
.Sp
Default \fIBitOrder\fR is \fIAscending\fR bit order which corresponds to first bit in each
byte as the loweset bit as opposed to the higest bit.
.IP "\fBGetBitsAsRawBinaryString\fR" 4
.IX Item "GetBitsAsRawBinaryString"
.Vb 1
\&    $BitString = $BitVector\->GetBitsAsRawBinaryString();
.Ve
.Sp
Returns values of bits in \fIBitVector\fR as an string corresponding to packed bit values
used by Perl vec function without perfoming any unpacking.
.IP "\fBGetDensityOfClearBits\fR" 4
.IX Item "GetDensityOfClearBits"
.Vb 1
\&    $ClearBitsDensity = $BitVector\->GetDensityOfClearBits();
.Ve
.Sp
Returns density of clear bits in \fIBitVector\fR which corresponds to number of bits set to 0
\&\fIBitVector\fR divided by its size.
.IP "\fBGetDensityOfSetBits\fR" 4
.IX Item "GetDensityOfSetBits"
.Vb 1
\&    $SetBitsDensity = $BitVector\->GetDensityOfSetBits();
.Ve
.Sp
Returns density of set bits in \fIBitVector\fR which corresponds to number of bits set to 1 in
\&\fIBitVector\fR divided by its size.
.IP "\fBGetNumOfClearBits\fR" 4
.IX Item "GetNumOfClearBits"
.Vb 1
\&    $NumOfClearBits = $BitVector\->GetNumOfClearBits();
.Ve
.Sp
Returns number of bits set to 0 in \fIBitVector\fR.
.IP "\fBGetNumOfSetBits\fR" 4
.IX Item "GetNumOfSetBits"
.Vb 1
\&    $NumOfSetBits = $BitVector\->GetNumOfSetBits();
.Ve
.Sp
Returns number of bits set to 1 in \fIBitVector\fR.
.IP "\fBGetSize\fR" 4
.IX Item "GetSize"
.Vb 1
\&    $Size = $BitVector\->GetSize();
.Ve
.Sp
Returns size of \fIBitVector\fR.
.IP "\fBIsBitClear\fR" 4
.IX Item "IsBitClear"
.Vb 1
\&    $Status = $BitVector\->IsBitClear();
.Ve
.Sp
Returns 1 or 0 based on whether \fIBitNum\fR is set to 0 in \fIBitVector\fR.
.IP "\fBIsBitSet\fR" 4
.IX Item "IsBitSet"
.Vb 1
\&    $Status = $BitVector\->IsBitSet($BitNum);
.Ve
.Sp
Returns 1 or 0 based on whether \fIBitNum\fR is set to 1 in \fIBitVector\fR.
.IP "\fBIsBitVector\fR" 4
.IX Item "IsBitVector"
.Vb 1
\&    $Status = BitVector::IsBitVector($Object);
.Ve
.Sp
Returns 1 or 0 based on whether \fIObject\fR is a \fBBitVector\fR object.
.IP "\fBNewFromBinaryString\fR" 4
.IX Item "NewFromBinaryString"
.Vb 4
\&    $NewBitVector = BitVector::NewFromBinaryString($BinaryString,
\&                    [$BitOrder]);
\&    $NewBitVector = $BitVector\->NewFromBinaryString($BinaryString,
\&                    [$BitOrder]);
.Ve
.Sp
Creates a new \fIBitVector\fR using \fIBinaryString\fR and returns new \fBBitVector\fR object.
.Sp
Default \fIBitOrder\fR is \fIAscending\fR bit order which corresponds to first bit in each
byte as the loweset bit as opposed to the higest bit.
.IP "\fBNewFromDecimalString\fR" 4
.IX Item "NewFromDecimalString"
.Vb 4
\&    $NewBitVector = BitVector::NewFromDecimalString($DecimalString,
\&                    [$BitOrder]);
\&    $NewBitVector = $BitVector\->NewFromDecimalString($DecimalString,
\&                    [$BitOrder]);
.Ve
.Sp
Creates a new \fIBitVector\fR using \fIDecimalString\fR and returns new \fBBitVector\fR object.
.Sp
Default \fIBitOrder\fR is \fIAscending\fR bit order which corresponds to first bit in each
byte as the loweset bit as opposed to the higest bit.
.IP "\fBNewFromHexadecimalString\fR" 4
.IX Item "NewFromHexadecimalString"
.Vb 4
\&    $NewBitVector = BitVector::NewFromHexadecimalString(
\&                    $HexadecimalString, [$BitOrder]);
\&    $NewBitVector = $BitVector\->NewFromHexadecimalString(
\&                    $HexadecimalString, [$BitOrder]);
.Ve
.Sp
Creates a new \fIBitVector\fR using \fIHexadecimalString\fR and returns new \fBBitVector\fR object.
.Sp
Default \fIBitOrder\fR is \fIAscending\fR bit order which corresponds to first bit in each
byte as the loweset bit as opposed to the higest bit.
.IP "\fBNewFromOctalString\fR" 4
.IX Item "NewFromOctalString"
.Vb 2
\&    $NewBitVector = BitVector::NewFromOctalString($OctalString, [$BitOrder]);
\&    $NewBitVector = $BitVector\->NewFromOctalString($OctalString, [$BitOrder]);
.Ve
.Sp
Creates a new \fIBitVector\fR using \fIOctalString\fR and returns new \fBBitVector\fR object.
.Sp
Default \fIBitOrder\fR is \fIAscending\fR bit order which corresponds to first bit in each
byte as the loweset bit as opposed to the higest bit.
.IP "\fBNewFromRawBinaryString\fR" 4
.IX Item "NewFromRawBinaryString"
.Vb 4
\&    $NewBitVector = BitVector::NewFromRawBinaryString(
\&                    $RawBinaryString);
\&    $NewBitVector = $BitVector\->NewFromRawBinaryString(
\&                    $RawBinaryString);
.Ve
.Sp
Creates a new \fIBitVector\fR using \fIRawBinaryString\fR and returns new \fBBitVector\fR object.
.IP "\fBReverse\fR" 4
.IX Item "Reverse"
.Vb 1
\&    $BitVector\->Reverse();
.Ve
.Sp
Reverses values of bits in \fIBitVector\fR and returns \fIBitVector\fR. First bit number ends up with
value of last bit number.
.IP "\fBSetAllBits\fR" 4
.IX Item "SetAllBits"
.Vb 1
\&    $BitVector\->SetAllBits();
.Ve
.Sp
Sets values of all bits in \fIBitVector\fR to 1 and returns \fIBitVector\fR.
.IP "\fBSetBit\fR" 4
.IX Item "SetBit"
.Vb 1
\&    $BitVector\->SetBit($BitNum);
.Ve
.Sp
Sets value of \fIBitNum\fR to 1 in \fIBitVector\fR and returns \fIBitVector\fR.
.IP "\fBSetBitValue\fR" 4
.IX Item "SetBitValue"
.Vb 1
\&    $BitVector\->SetBitValue($BitNum, $BitValue);
.Ve
.Sp
Sets value of \fIBitNum\fR to \fIBitValue\fR in \fIBitVector\fR and returns \fIBitVector\fR.
.IP "\fBSetBitValueBitOrder\fR" 4
.IX Item "SetBitValueBitOrder"
.Vb 2
\&    BitVector::SetBitValueBitOrder($BitOrder);
\&    $BitVector\->SetBitValueBitOrder($BitOrder);
.Ve
.Sp
Set bit order for printing \fBBitVector\fR values during stringification of \fBBitVector\fR object.
Possible bit order values: \fIAscending or Descending\fR.
.Sp
Bit order can be set for either an individual \fBBitVector\fR object or the class. Default is
to print bits in each byte in \fIAsscending\fR bit order.
.Sp
Internally, bits are stored in \fIAscending\fR bit order using Perl vec function. Regardless
of machine order, big-endian or little-endian, vec function always considers first
string byte as the lowest byte and first bit within each byte as the lowest bit.
.IP "\fBSetBitValuePrintFormat\fR" 4
.IX Item "SetBitValuePrintFormat"
.Vb 2
\&    BitVector::SetBitValuePrintFormat($PrintValueFormat);
\&    $BitVector\->SetBitValuePrintFormat($PrintValueFormat);
.Ve
.Sp
Set bit values print format for printing \fBBitVector\fR values during stringification of \fBBitVector\fR
object. Possible print format values: \fIBinary, Bin, Hexadecimal, Hex, Decimal, Dec, Octal,
Oct, RawBinary, RawBin\fR. Default: \fIBinary\fR.
.Sp
Bit values print format can be set for either an individual \fBBitVector\fR object or the class.
.IP "\fBSetBits\fR" 4
.IX Item "SetBits"
.Vb 1
\&    $BitVector\->SetBits(@BitNums);
.Ve
.Sp
Set specified bit numbers \fIBitNums\fR to 1 in \fIBitVector\fR object and return \fIBitVector\fR.
.IP "\fBSetBitsAsBinaryString\fR" 4
.IX Item "SetBitsAsBinaryString"
.Vb 1
\&    $BitVector\->SetBitsAsBinaryString($BinaryString);
.Ve
.Sp
Set bit values in \fIBitVector\fR using specified \fIBinaryString\fR and return \fIBitVector\fR. The
size of \fIBitVector\fR is not changed.
.IP "\fBSetBitsAsDecimalString\fR" 4
.IX Item "SetBitsAsDecimalString"
.Vb 1
\&    $BitVector\->SetBitsAsDecimalString($DecimalString, [$BitOrder]);
.Ve
.Sp
Set bit values in \fIBitVector\fR using specified \fIDecimalString\fR and return \fIBitVector\fR. The
size of \fIBitVector\fR is not changed.
.IP "\fBSetBitsAsHexadecimalString\fR" 4
.IX Item "SetBitsAsHexadecimalString"
.Vb 1
\&    $BitVector\->SetBitsAsHexadecimalString($HexadecimalString, [$BitOrder]);
.Ve
.Sp
Set bit values in \fIBitVector\fR using specified \fIHexadecimalString\fR and return \fIBitVector\fR. The
size of \fIBitVector\fR is not changed.
.IP "\fBSetBitsAsOctalString\fR" 4
.IX Item "SetBitsAsOctalString"
.Vb 1
\&    $BitVector\->SetBitsAsOctalString($OctalString, [$BitOrder]);
.Ve
.Sp
Set bit values in \fIBitVector\fR using specified \fIOctalString\fR and return \fIBitVector\fR. The
size of \fIBitVector\fR is not changed.
.IP "\fBSetBitsAsRawBinaryString\fR" 4
.IX Item "SetBitsAsRawBinaryString"
.Vb 1
\&    $BitVector\->SetBitsAsRawBinaryString($RawBinaryString);
.Ve
.Sp
Set bit values in \fIBitVector\fR using specified \fIRawBinaryString\fR and return \fIBitVector\fR. The
size of \fIBitVector\fR is not changed.
.IP "\fBSetBitsRange\fR" 4
.IX Item "SetBitsRange"
.Vb 1
\&    $BitVector\->SetBitsRange($MinBitNum, $MaxBitNum);
.Ve
.Sp
Set specified bit numbers between \fIMinBitNum\fR and \fIMaxBitNum\fR to 1 in \fIBitVector\fR
object and return \fIBitVector\fR.
.IP "\fBStringifyBitVector\fR" 4
.IX Item "StringifyBitVector"
.Vb 1
\&    $String = $BitVector\->StringifyBitVector();
.Ve
.Sp
Returns a string containing information about \fIBitVector\fR object.
.SH "AUTHOR"
.IX Header "AUTHOR"
Manish Sud <msud@san.rr.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Vector.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2020 Manish Sud. All rights reserved.
.PP
This file is part of MayaChemTools.
.PP
MayaChemTools is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option)
any later version.
