.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TextUtil 1"
.TH TextUtil 1 "2020-08-27" "perl v5.22.4" "MayaChemTools"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TextUtil
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use TextUtil;
.PP
use TextUtil qw(:all);
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBTextUtil\fR module provides the following functions:
.PP
AddNumberSuffix, ContainsWhiteSpaces, GetTextFileDataByNonUniqueKey,
GetTextFileDataByUniqueKey, GetTextLine, HashCode, IsEmpty, IsFloat, IsInteger,
IsNotEmpty, IsNumberPowerOfNumber, IsNumerical, IsPositiveInteger, JoinWords,
QuoteAWord, RemoveLeadingAndTrailingWhiteSpaces, RemoveLeadingWhiteSpaces,
RemoveTrailingWhiteSpaces, SplitWords, WrapText
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "\fBAddNumberSuffix\fR" 4
.IX Item "AddNumberSuffix"
.Vb 1
\&    $NumberWithSuffix = AddNumberSuffix($IntegerValue);
.Ve
.Sp
Returns number with appropriate suffix: 0, 1st, 2nd, 3rd, 4th, and so on.
.IP "\fBContainsWhiteSpaces\fR" 4
.IX Item "ContainsWhiteSpaces"
.Vb 1
\&    $Status = ContainsWhiteSpaces($TheString);
.Ve
.Sp
Returns 1 or 0 based on whether the string contains any white spaces.
.IP "\fBGetTextLine\fR" 4
.IX Item "GetTextLine"
.Vb 1
\&    $Line = GetTextLine(\e*TEXTFILE);
.Ve
.Sp
Reads next line from an already opened text file, takes out any carriage return,
and returns it as a string. \s-1NULL\s0 is returned for \s-1EOF.\s0
.IP "\fBGetTextFileDataByNonUniqueKey\fR" 4
.IX Item "GetTextFileDataByNonUniqueKey"
.Vb 2
\&    GetTextFileDataByNonUniqueKey($TextDataFile, $TextDataMapRef,
\&                                  $DataKeyColNum, $InDelim);
.Ve
.Sp
Load data from a text file into the specified hash reference using a specific
column for non-unique data key values.
.Sp
The lines starting with # are treated as comments and ignored. First line
not starting with # must contain column labels and the number of columns in
all other data rows must match the number of column labels.
.Sp
The first column is assumed to contain data key value by default; all other columns
contain data as indicated in their column labels.
.Sp
In order to avoid dependence of data access on the specified column labels, the
column data is loaded into hash with Column<Num> hash keys, where column number
start from 1. The data key column is not available as Colnum<Num> hash key;
.Sp
The format of the data structure loaded into a specified hash reference is:
.Sp
.Vb 7
\&    @{$TextDataMapRef\->{DataKeys}} \- Array of unique data keys
\&    @{$TextDataMapRef\->{ColLabels}} \- Array of column labels
\&    @{$TextDataMapRef\->{DataColIDs}} \- Array of data column IDs
\&    $TextDataMapRef\->{NumOfCols} \- Number of columns
\&    %{$TextDataMapRef\->{DataKey}} \- Hash keys pair: <DataKey, DataKey>
\&    @{$TextDataMapRef\->{DataCol<Num>}} \- Hash keys pair with data as an array:
\&                                         <DataCol<Num>, DataKey>
.Ve
.IP "\fBGetTextFileDataByUniqueKey\fR" 4
.IX Item "GetTextFileDataByUniqueKey"
.Vb 2
\&    GetTextFileDataByUniqueKey($TextDataFile, $TextDataMapRef, $DataKeyColNum,
\&                                $InDelim);
.Ve
.Sp
Load data from a text file into the specified hash reference using a a specific
column for unique data key values.
.Sp
The lines starting with # are treated as comments and ignored. First line
not starting with # must contain column labels and the number of columns in
all other data rows must match the number of column labels.
.Sp
The first column is assumed to contain data key value by default; all other columns
contain data as indicated in their column labels.
.Sp
In order to avoid dependence of data access on the specified column labels, the
column data is loaded into hash with Column<Num> hash keys, where column number
start from 1. The data key column is not available as Colnum<Num> hash key;
.Sp
The format of the data structure loaded into a specified hash reference is:
.Sp
.Vb 6
\&    @{$TextDataMapRef\->{DataKeys}} \- Array of unique data keys
\&    @{$TextDataMapRef\->{ColLabels}} \- Array of column labels
\&    @{$TextDataMapRef\->{DataColIDs}} \- Array of data column IDs
\&    $TextDataMapRef\->{NumOfCols} \- Number of columns
\&    %{$TextDataMapRef\->{DataKey}} \- Hash keys pair: <DataKey, DataKey>
\&    %{$TextDataMapRef\->{DataCol<Num>}} \- Hash keys pair: <DataCol<Num>, DataKey>
.Ve
.IP "\fBHashCode\fR" 4
.IX Item "HashCode"
.Vb 1
\&    $HashCode = HashCode($TheString);
.Ve
.Sp
Returns a 32 bit integer hash code using One-at-a-time algorithm By Bob Jenkins [Ref 38].
It's also implemented in Perl for internal hash keys in hv.h include file.
.IP "\fBIsEmpty\fR" 4
.IX Item "IsEmpty"
.Vb 1
\&    $Status = IsEmpty($TheString);
.Ve
.Sp
Returns 1 or 0 based on whether the string is empty.
.IP "\fBIsInteger\fR" 4
.IX Item "IsInteger"
.Vb 1
\&    $Status = IsInteger($TheString);
.Ve
.Sp
Returns 1 or 0 based on whether the string is a positive integer.
.IP "\fBIsPositiveInteger\fR" 4
.IX Item "IsPositiveInteger"
.Vb 1
\&    $Status = IsPositiveInteger($TheString);
.Ve
.Sp
Returns 1 or 0 based on whether the string is an integer.
.IP "\fBIsFloat\fR" 4
.IX Item "IsFloat"
.Vb 1
\&    $Status = IsFloat($TheString);
.Ve
.Sp
Returns 1 or 0 based on whether the string is a float.
.IP "\fBIsNotEmpty\fR" 4
.IX Item "IsNotEmpty"
.Vb 1
\&    $Status = IsNotEmpty($TheString);
.Ve
.Sp
Returns 0 or 1 based on whether the string is empty.
.IP "\fBIsNumerical\fR" 4
.IX Item "IsNumerical"
.Vb 1
\&    $Status = IsNumerical($TheString);
.Ve
.Sp
Returns 1 or 0 based on whether the string is a number.
.IP "\fBIsNumberPowerOfNumber\fR" 4
.IX Item "IsNumberPowerOfNumber"
.Vb 1
\&    $Status = IsNumberPowerOfNumber($FirstNum, $SecondNum);
.Ve
.Sp
Returns 1 or 0 based on whether the first number is a power of second number.
.IP "\fBJoinWords\fR" 4
.IX Item "JoinWords"
.Vb 1
\&    $JoinedWords = JoinWords($Words, $Delim, $Quote);
.Ve
.Sp
Joins different words using delimiter and quote parameters, and returns it
as a string.
.IP "\fBQuoteAWord\fR" 4
.IX Item "QuoteAWord"
.Vb 1
\&    $QuotedWord = QuoteAWord($Word, $Quote);
.Ve
.Sp
Returns a quoted string based on \fIQuote\fR value.
.IP "\fBRemoveLeadingWhiteSpaces\fR" 4
.IX Item "RemoveLeadingWhiteSpaces"
.Vb 1
\&    $OutString = RemoveLeadingWhiteSpaces($InString);
.Ve
.Sp
Returns a string without any leading and traling white spaces.
.IP "\fBRemoveTrailingWhiteSpaces\fR" 4
.IX Item "RemoveTrailingWhiteSpaces"
.Vb 1
\&    $OutString = RemoveTrailingWhiteSpaces($InString);
.Ve
.Sp
Returns a string without any trailing white spaces.
.IP "\fBRemoveLeadingAndTrailingWhiteSpaces\fR" 4
.IX Item "RemoveLeadingAndTrailingWhiteSpaces"
.Vb 1
\&    $OutString = RemoveLeadingAndTrailingWhiteSpaces($InString);
.Ve
.Sp
Returns a string without any leading and traling white spaces.
.IP "\fBSplitWords\fR" 4
.IX Item "SplitWords"
.Vb 1
\&    @Words = SplitWords($Line, $Delimiter);
.Ve
.Sp
Returns an array \fIWords\fR ontaining unquoted words generated after spliting
string value \fILine\fR containing quoted or unquoted words.
.Sp
This function is used to split strings generated by JoinWords as replacement
for Perl's core module funtion \fIText::ParseWords::quotewords()\fR which dumps core
on very long strings.
.IP "\fBWrapText\fR" 4
.IX Item "WrapText"
.Vb 1
\&    $OutString = WrapText($InString, [$WrapLength, $WrapDelimiter]);
.Ve
.Sp
Returns a wrapped string. By default, \fIWrapLenght\fR is \fI40\fR and \fIWrapDelimiter\fR
is Unix new line character.
.SH "AUTHOR"
.IX Header "AUTHOR"
Manish Sud <msud@san.rr.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
FileUtil.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2020 Manish Sud. All rights reserved.
.PP
This file is part of MayaChemTools.
.PP
MayaChemTools is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 Lesser General Public License as published by the Free
Software Foundation; either version 3 of the License, or (at your option)
any later version.
