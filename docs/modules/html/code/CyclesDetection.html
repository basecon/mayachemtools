<html>
<head>
<title>MayaChemTools:Code:Graph/CyclesDetection.pm</title>
<meta http-equiv="content-type" content="text/html;charset=utf-8">
<link rel="stylesheet" type="text/css" href="../../../css/MayaChemToolsCode.css">
</head>
<body leftmargin="20" rightmargin="20" topmargin="10" bottommargin="10">
<br/>
<center>
<a href="http://www.mayachemtools.org" title="MayaChemTools Home"><img src="../../../images/MayaChemToolsLogo.gif" border="0" alt="MayaChemTools"></a>
</center>
<br/>
<pre>
<a name="package-Graph::CyclesDetection-"></a>   1 <span class="k">package </span><span class="i">Graph::CyclesDetection</span><span class="sc">;</span>
   2 <span class="c">#</span>
   3 <span class="c"># File: CyclesDetection.pm</span>
   4 <span class="c"># Author: Manish Sud &lt;msud@san.rr.com&gt;</span>
   5 <span class="c">#</span>
   6 <span class="c"># Copyright (C) 2020 Manish Sud. All rights reserved.</span>
   7 <span class="c">#</span>
   8 <span class="c"># This file is part of MayaChemTools.</span>
   9 <span class="c">#</span>
  10 <span class="c"># MayaChemTools is free software; you can redistribute it and/or modify it under</span>
  11 <span class="c"># the terms of the GNU Lesser General Public License as published by the Free</span>
  12 <span class="c"># Software Foundation; either version 3 of the License, or (at your option) any</span>
  13 <span class="c"># later version.</span>
  14 <span class="c">#</span>
  15 <span class="c"># MayaChemTools is distributed in the hope that it will be useful, but without</span>
  16 <span class="c"># any warranty; without even the implied warranty of merchantability of fitness</span>
  17 <span class="c"># for a particular purpose.  See the GNU Lesser General Public License for more</span>
  18 <span class="c"># details.</span>
  19 <span class="c">#</span>
  20 <span class="c"># You should have received a copy of the GNU Lesser General Public License</span>
  21 <span class="c"># along with MayaChemTools; if not, see &lt;http://www.gnu.org/licenses/&gt; or</span>
  22 <span class="c"># write to the Free Software Foundation Inc., 59 Temple Place, Suite 330,</span>
  23 <span class="c"># Boston, MA, 02111-1307, USA.</span>
  24 <span class="c">#</span>
  25 
  26 <span class="k">use</span> <span class="w">strict</span><span class="sc">;</span>
  27 <span class="k">use</span> <span class="w">Carp</span><span class="sc">;</span>
  28 <span class="k">use</span> <span class="w">Exporter</span><span class="sc">;</span>
  29 <span class="k">use</span> <span class="w">Graph</span><span class="sc">;</span>
  30 <span class="k">use</span> <span class="w">Graph::Path</span><span class="sc">;</span>
  31 <span class="k">use</span> <span class="w">Graph::PathGraph</span><span class="sc">;</span>
  32 <span class="k">use</span> <span class="w">BitVector</span><span class="sc">;</span>
  33 
  34 <span class="k">use</span> <span class="w">vars</span> <span class="q">qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS)</span><span class="sc">;</span>
  35 
  36 <span class="i">@ISA</span> = <span class="q">qw(Exporter)</span><span class="sc">;</span>
  37 <span class="i">@EXPORT</span> = <span class="q">qw()</span><span class="sc">;</span>
  38 <span class="i">@EXPORT_OK</span> = <span class="q">qw()</span><span class="sc">;</span>
  39 
  40 <span class="i">%EXPORT_TAGS</span> = <span class="s">(</span><span class="w">all</span>  <span class="cm">=&gt;</span> <span class="s">[</span><span class="i">@EXPORT</span><span class="cm">,</span> <span class="i">@EXPORT_OK</span><span class="s">]</span><span class="s">)</span><span class="sc">;</span>
  41 
  42 <span class="c"># Setup class variables...</span>
  43 <span class="k">my</span><span class="s">(</span><span class="i">$ClassName</span><span class="s">)</span><span class="sc">;</span>
  44 <span class="i">_InitializeClass</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
  45 
  46 <span class="c"># Overload Perl functions...</span>
  47 <span class="k">use</span> <span class="w">overload</span> <span class="q">&#39;&quot;&quot;&#39;</span> <span class="cm">=&gt;</span> <span class="q">&#39;StringifyCyclesDetection&#39;</span><span class="sc">;</span>
  48 
  49 <span class="c"># Class constructor...</span>
<a name="new-"></a>  50 <span class="k">sub </span><span class="m">new</span> <span class="s">{</span>
  51   <span class="k">my</span><span class="s">(</span><span class="i">$Class</span><span class="cm">,</span> <span class="i">$Graph</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
  52 
  53   <span class="c"># Initialize object...</span>
  54   <span class="k">my</span> <span class="i">$This</span> = <span class="s">{</span><span class="s">}</span><span class="sc">;</span>
  55   <span class="k">bless</span> <span class="i">$This</span><span class="cm">,</span> <span class="k">ref</span><span class="s">(</span><span class="i">$Class</span><span class="s">)</span> || <span class="i">$Class</span><span class="sc">;</span>
  56   <span class="i">$This</span><span class="i">-&gt;_InitializeCyclesDetection</span><span class="s">(</span><span class="i">$Graph</span><span class="s">)</span><span class="sc">;</span>
  57 
  58   <span class="k">return</span> <span class="i">$This</span><span class="sc">;</span>
  59 <span class="s">}</span>
  60 
  61 <span class="c"># Initialize object data...</span>
<a name="_InitializeCyclesDetection-"></a>  62 <span class="k">sub </span><span class="m">_InitializeCyclesDetection</span> <span class="s">{</span>
  63   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="cm">,</span> <span class="i">$Graph</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
  64 
  65   <span class="i">$This</span>-&gt;{<span class="w">Graph</span>} = <span class="i">$Graph</span><span class="sc">;</span>
  66 
  67   <span class="c"># Cycles list...</span>
  68   <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}} = <span class="s">(</span><span class="s">)</span><span class="sc">;</span>
  69 
  70   <span class="c"># Cyclic paths which are not part of any other cycle...</span>
  71   <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">IndependentCyclicPaths</span>}} = <span class="s">(</span><span class="s">)</span><span class="sc">;</span>
  72 
  73   <span class="k">return</span> <span class="i">$This</span><span class="sc">;</span>
  74 <span class="s">}</span>
  75 
  76 <span class="c"># Initialize class ...</span>
<a name="_InitializeClass-"></a>  77 <span class="k">sub </span><span class="m">_InitializeClass</span> <span class="s">{</span>
  78   <span class="c">#Class name...</span>
  79   <span class="i">$ClassName</span> = <span class="w">__PACKAGE__</span><span class="sc">;</span>
  80 <span class="s">}</span>
  81 
  82 <span class="c"># Detect all cycles in graph...</span>
  83 <span class="c">#</span>
<a name="DetectCycles-"></a>  84 <span class="k">sub </span><span class="m">DetectCycles</span> <span class="s">{</span>
  85   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
  86 
  87   <span class="k">return</span> <span class="i">$This</span><span class="i">-&gt;DetectCyclesUsingCollapsingPathGraphMethodology</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
  88 <span class="s">}</span>
  89 
  90 <span class="c"># Detect all cycles in the graph using collapsing path graph [Ref 31] methodology...</span>
  91 <span class="c">#</span>
  92 <span class="c"># Note:</span>
  93 <span class="c">#   . For topologically complex graphs containing large number of cycles,</span>
  94 <span class="c">#     CollapseVertexAndCollectCyclicPathsDetectCycles method implemented in</span>
  95 <span class="c">#     PathGraph can time out in which case no cycles are detected or</span>
  96 <span class="c">#     assigned.</span>
  97 <span class="c">#</span>
<a name="DetectCyclesUsingCollapsingPathGraphMethodology-"></a>  98 <span class="k">sub </span><span class="m">DetectCyclesUsingCollapsingPathGraphMethodology</span> <span class="s">{</span>
  99   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
 100   <span class="k">my</span><span class="s">(</span><span class="i">$PathGraph</span><span class="s">)</span><span class="sc">;</span>
 101 
 102   <span class="c"># Create a path graph...</span>
 103   <span class="i">$PathGraph</span> = <span class="i">new</span> <span class="i">Graph::PathGraph</span><span class="s">(</span><span class="i">$This</span>-&gt;{<span class="w">Graph</span>}<span class="s">)</span><span class="sc">;</span>
 104 
 105   <span class="c"># For a vertex to be in a cycle, its degree must be &gt;=2. So delete vertices recursively</span>
 106   <span class="c"># till all vertices with degree less than 2 have been deleted...</span>
 107   <span class="i">$PathGraph</span><span class="i">-&gt;DeleteVerticesWithDegreeLessThan</span><span class="s">(</span><span class="n">2</span><span class="s">)</span><span class="sc">;</span>
 108 
 109   <span class="c"># Setup a VertexID and EdgeID to index map usage during retrieval of independent cycles to</span>
 110   <span class="c"># avoid going over all vertices in all cylic paths later...</span>
 111   <span class="c">#</span>
 112   <span class="k">my</span><span class="s">(</span><span class="i">$VertexIDsToIndicesRef</span><span class="cm">,</span> <span class="i">$LargestVertexIndex</span><span class="cm">,</span> <span class="i">$EdgeIDsToIndicesRef</span><span class="cm">,</span> <span class="i">$LargestEdgeIDIndex</span><span class="s">)</span><span class="sc">;</span>
 113   <span class="s">(</span><span class="i">$VertexIDsToIndicesRef</span><span class="cm">,</span> <span class="i">$LargestVertexIndex</span><span class="s">)</span> = <span class="i">$This</span><span class="i">-&gt;_SetupVertexIDsToIndicesMap</span><span class="s">(</span><span class="i">$PathGraph</span><span class="s">)</span><span class="sc">;</span>
 114   <span class="s">(</span><span class="i">$EdgeIDsToIndicesRef</span><span class="cm">,</span> <span class="i">$LargestEdgeIDIndex</span><span class="s">)</span> = <span class="i">$This</span><span class="i">-&gt;_SetupEdgeIDsToIndicesMap</span><span class="s">(</span><span class="i">$PathGraph</span><span class="s">)</span><span class="sc">;</span>
 115 
 116   <span class="c"># Recursively collapse vertices with lowest degree...</span>
 117   <span class="k">my</span><span class="s">(</span><span class="i">$VertexID</span><span class="cm">,</span> <span class="i">$CycleVertexID</span><span class="s">)</span><span class="sc">;</span>
 118   <span class="k">while</span> <span class="s">(</span><span class="i">$VertexID</span> = <span class="i">$PathGraph</span><span class="i">-&gt;GetVertexWithSmallestDegree</span><span class="s">(</span><span class="s">)</span><span class="s">)</span> <span class="s">{</span>
 119       <span class="k">if</span> <span class="s">(</span>!<span class="i">$PathGraph</span><span class="i">-&gt;CollapseVertexAndCollectCyclicPaths</span><span class="s">(</span><span class="i">$VertexID</span><span class="s">)</span><span class="s">)</span> <span class="s">{</span>
 120         <span class="c"># Cycles detection didn&#39;t finish...</span>
 121         <span class="k">return</span> <span class="k">undef</span><span class="sc">;</span>
 122       <span class="s">}</span>
 123   <span class="s">}</span>
 124 
 125   <span class="c"># Get detected cycles and save &#39;em sorted by size...</span>
 126   <span class="k">push</span> <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}}<span class="cm">,</span> <span class="k">sort</span> <span class="s">{</span> <span class="i">$a</span><span class="i">-&gt;GetLength</span><span class="s">(</span><span class="s">)</span> &lt;=&gt; <span class="i">$b</span><span class="i">-&gt;GetLength</span><span class="s">(</span><span class="s">)</span> <span class="s">}</span> <span class="i">$PathGraph</span><span class="i">-&gt;GetCyclicPaths</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 127 
 128   <span class="c"># Retrieve independent cyclic paths...</span>
 129   <span class="k">return</span> <span class="i">$This</span><span class="i">-&gt;_RetrieveIndependentCycles</span><span class="s">(</span><span class="i">$VertexIDsToIndicesRef</span><span class="cm">,</span> <span class="i">$LargestVertexIndex</span><span class="cm">,</span> <span class="i">$EdgeIDsToIndicesRef</span><span class="cm">,</span> <span class="i">$LargestEdgeIDIndex</span><span class="s">)</span><span class="sc">;</span>
 130 <span class="s">}</span>
 131 
 132 <span class="c"># Retrieve and save independent cyclic paths...</span>
 133 <span class="c">#</span>
 134 <span class="c"># Set of independent cycles identified using this method doesn&#39;t correspond to basis set of</span>
 135 <span class="c"># rings or smallest set of smallest rings (SSSR) [ Refs 29-30 ]; instead, set of cycles identified</span>
 136 <span class="c"># as independent cycles simply correspond to cycles which contain no other cycle as their</span>
 137 <span class="c"># subcycles and can&#39;t be described as linear combination of smaller cycles. And it also happen</span>
 138 <span class="c"># to contain all the rings in basis set of rings and SSSR. In other words, it&#39;s a superset of basis set</span>
 139 <span class="c"># of cycles and SSSR. For example, six four membered cycles are identified for cubane which is one</span>
 140 <span class="c"># more than the basis set of cycles.</span>
 141 <span class="c">#</span>
<a name="_RetrieveIndependentCycles-"></a> 142 <span class="k">sub </span><span class="m">_RetrieveIndependentCycles</span> <span class="s">{</span>
 143   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="cm">,</span> <span class="i">$VertexIDsToIndicesRef</span><span class="cm">,</span> <span class="i">$LargestVertexIndex</span><span class="cm">,</span> <span class="i">$EdgeIDsToIndicesRef</span><span class="cm">,</span> <span class="i">$LargestEdgeIDIndex</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
 144 
 145   <span class="c"># Only 1 or 0 cyclic paths...</span>
 146   <span class="k">if</span> <span class="s">(</span><span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}} &lt;= <span class="n">1</span><span class="s">)</span> <span class="s">{</span>
 147     <span class="k">push</span> <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">IndependentCyclicPaths</span>}}<span class="cm">,</span> <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}}<span class="sc">;</span>
 148     <span class="k">return</span> <span class="i">$This</span><span class="sc">;</span>
 149   <span class="s">}</span>
 150 
 151   <span class="c"># Setup bit vectors for each cyclic path with size of each bit vector corresponding to</span>
 152   <span class="c"># maximum vertex index plus one...</span>
 153   <span class="k">my</span><span class="s">(</span><span class="i">$CyclicPath</span><span class="cm">,</span> <span class="i">$BitVector</span><span class="cm">,</span> <span class="i">@BitNums</span><span class="cm">,</span> <span class="i">@CyclicPathBitVectors</span><span class="cm">,</span> <span class="i">@CyclicPathEdgeIDsBitVectors</span><span class="s">)</span><span class="sc">;</span>
 154 
 155   <span class="i">@CyclicPathBitVectors</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span> <span class="i">@CyclicPathEdgeIDsBitVectors</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 156 
 157   <span class="c"># Set bits corresponding to VertexIDs EdgeIDs using their indices...</span>
 158   <span class="k">for</span> <span class="i">$CyclicPath</span> <span class="s">(</span><span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}}<span class="s">)</span> <span class="s">{</span>
 159     <span class="i">$BitVector</span> = <span class="i">new</span> <span class="i">BitVector</span><span class="s">(</span><span class="i">$LargestVertexIndex</span><span class="s">)</span><span class="sc">;</span>
 160     <span class="i">@BitNums</span> = <span class="k">map</span> <span class="s">{</span> <span class="i">$VertexIDsToIndicesRef</span>-&gt;{<span class="i">$_</span>} <span class="s">}</span> <span class="i">$CyclicPath</span><span class="i">-&gt;GetVertices</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 161     <span class="i">$BitVector</span><span class="i">-&gt;SetBits</span><span class="s">(</span><span class="i">@BitNums</span><span class="s">)</span><span class="sc">;</span>
 162     <span class="k">push</span> <span class="i">@CyclicPathBitVectors</span><span class="cm">,</span> <span class="i">$BitVector</span><span class="sc">;</span>
 163 
 164     <span class="i">$BitVector</span> = <span class="i">new</span> <span class="i">BitVector</span><span class="s">(</span><span class="i">$LargestEdgeIDIndex</span><span class="s">)</span><span class="sc">;</span>
 165     <span class="i">@BitNums</span> = <span class="k">map</span> <span class="s">{</span> <span class="i">$EdgeIDsToIndicesRef</span>-&gt;{<span class="i">$_</span>} <span class="s">}</span> <span class="i">$This</span><span class="i">-&gt;_GetPathEdgeIDs</span><span class="s">(</span><span class="i">$CyclicPath</span><span class="s">)</span><span class="sc">;</span>
 166     <span class="i">$BitVector</span><span class="i">-&gt;SetBits</span><span class="s">(</span><span class="i">@BitNums</span><span class="s">)</span><span class="sc">;</span>
 167     <span class="k">push</span> <span class="i">@CyclicPathEdgeIDsBitVectors</span><span class="cm">,</span> <span class="i">$BitVector</span><span class="sc">;</span>
 168   <span class="s">}</span>
 169 
 170   <span class="c"># First smallest cyclic path always ends up as an independent cyclic path...</span>
 171   <span class="k">push</span> <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">IndependentCyclicPaths</span>}}<span class="cm">,</span> <span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}[<span class="n">0</span>]<span class="sc">;</span>
 172 
 173   <span class="c"># Retrieve other independent cyclic paths...</span>
 174   <span class="k">my</span><span class="s">(</span><span class="i">$CurrentIndex</span><span class="cm">,</span> <span class="i">$PreviousIndex</span><span class="cm">,</span> <span class="i">$CurrentCyclicPath</span><span class="cm">,</span> <span class="i">$PreviousCyclicPath</span><span class="cm">,</span> <span class="i">$CurrentPathLength</span><span class="cm">,</span> <span class="i">$PreviousPathLength</span><span class="cm">,</span> <span class="i">$CurrentBitVector</span><span class="cm">,</span> <span class="i">$PreviousBitVector</span><span class="cm">,</span> <span class="i">$CurrentAndPreviousBitVectpor</span><span class="cm">,</span> <span class="i">$AllPreviousSmallerPathsBitVector</span><span class="cm">,</span> <span class="i">$AllPreviousSmallerPathsEdgeIDsBitVector</span><span class="cm">,</span> <span class="i">$CurrentEdgeIDsBitVector</span><span class="cm">,</span> <span class="i">$AndBitVector</span><span class="cm">,</span> <span class="i">%SmallerPathAlreadyAdded</span><span class="cm">,</span> <span class="i">%SkipPath</span><span class="s">)</span><span class="sc">;</span>
 175 
 176   <span class="i">%SkipPath</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 177   <span class="i">%SmallerPathAlreadyAdded</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 178   <span class="i">$AllPreviousSmallerPathsBitVector</span> = <span class="i">new</span> <span class="i">BitVector</span><span class="s">(</span><span class="i">$LargestVertexIndex</span><span class="s">)</span><span class="sc">;</span>
 179   <span class="i">$AllPreviousSmallerPathsEdgeIDsBitVector</span> = <span class="i">new</span> <span class="i">BitVector</span><span class="s">(</span><span class="i">$LargestEdgeIDIndex</span><span class="s">)</span><span class="sc">;</span>
 180 
 181   <span class="j">CURRENT:</span> <span class="k">for</span> <span class="i">$CurrentIndex</span> <span class="s">(</span><span class="n">1</span> .. <span class="i">$#</span>{<span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}}<span class="s">)</span> <span class="s">{</span>
 182     <span class="k">if</span> <span class="s">(</span><span class="k">exists</span> <span class="i">$SkipPath</span>{<span class="i">$CurrentIndex</span>}<span class="s">)</span> <span class="s">{</span>
 183       <span class="k">next</span> <span class="j">CURRENT</span><span class="sc">;</span>
 184     <span class="s">}</span>
 185     <span class="i">$CurrentCyclicPath</span> = <span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}[<span class="i">$CurrentIndex</span>]<span class="sc">;</span>
 186     <span class="i">$CurrentBitVector</span> = <span class="i">$CyclicPathBitVectors</span>[<span class="i">$CurrentIndex</span>]<span class="sc">;</span>
 187     <span class="i">$CurrentPathLength</span> = <span class="i">$CurrentCyclicPath</span><span class="i">-&gt;GetLength</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 188 
 189     <span class="j">PREVIOUS:</span> <span class="k">for</span> <span class="i">$PreviousIndex</span> <span class="s">(</span><span class="n">0</span> .. <span class="s">(</span><span class="i">$CurrentIndex</span> - <span class="n">1</span><span class="s">)</span><span class="s">)</span> <span class="s">{</span>
 190       <span class="k">if</span> <span class="s">(</span><span class="k">exists</span> <span class="i">$SkipPath</span>{<span class="i">$PreviousIndex</span>}<span class="s">)</span> <span class="s">{</span>
 191         <span class="k">next</span> <span class="j">PREVIOUS</span><span class="sc">;</span>
 192       <span class="s">}</span>
 193       <span class="i">$PreviousCyclicPath</span> = <span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}[<span class="i">$PreviousIndex</span>]<span class="sc">;</span>
 194       <span class="i">$PreviousBitVector</span> = <span class="i">$CyclicPathBitVectors</span>[<span class="i">$PreviousIndex</span>]<span class="sc">;</span>
 195 
 196       <span class="c"># Is previous path a subset of current path?</span>
 197       <span class="i">$CurrentAndPreviousBitVectpor</span> = <span class="i">$PreviousBitVector</span> &amp;  <span class="i">$CurrentBitVector</span><span class="sc">;</span>
 198       <span class="k">if</span> <span class="s">(</span><span class="i">$PreviousBitVector</span><span class="i">-&gt;GetNumOfSetBits</span><span class="s">(</span><span class="s">)</span> == <span class="i">$CurrentAndPreviousBitVectpor</span><span class="i">-&gt;GetNumOfSetBits</span><span class="s">(</span><span class="s">)</span><span class="s">)</span> <span class="s">{</span>
 199         <span class="c"># Current path doesn&#39;t qualify an independent path...</span>
 200         <span class="i">$SkipPath</span>{<span class="i">$CurrentIndex</span>} = <span class="n">1</span><span class="sc">;</span>
 201         <span class="k">next</span> <span class="j">CURRENT</span><span class="sc">;</span>
 202       <span class="s">}</span>
 203 
 204       <span class="i">$PreviousPathLength</span> = <span class="i">$PreviousCyclicPath</span><span class="i">-&gt;GetLength</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 205       <span class="k">if</span> <span class="s">(</span><span class="i">$PreviousPathLength</span> &lt; <span class="i">$CurrentPathLength</span><span class="s">)</span> <span class="s">{</span>
 206         <span class="c"># Mark cycle vertices seen in cyclic paths with length smaller than current path...</span>
 207         <span class="k">if</span> <span class="s">(</span>! <span class="k">exists</span> <span class="i">$SmallerPathAlreadyAdded</span>{<span class="i">$PreviousIndex</span>}<span class="s">)</span> <span class="s">{</span>
 208           <span class="i">$SmallerPathAlreadyAdded</span>{<span class="i">$PreviousIndex</span>} = <span class="n">1</span><span class="sc">;</span>
 209           <span class="i">$AllPreviousSmallerPathsBitVector</span> = <span class="i">$AllPreviousSmallerPathsBitVector</span> | <span class="i">$PreviousBitVector</span><span class="sc">;</span>
 210           <span class="i">$AllPreviousSmallerPathsEdgeIDsBitVector</span> = <span class="i">$AllPreviousSmallerPathsEdgeIDsBitVector</span> | <span class="i">$CyclicPathEdgeIDsBitVectors</span>[<span class="i">$PreviousIndex</span>]<span class="sc">;</span>
 211         <span class="s">}</span>
 212       <span class="s">}</span>
 213     <span class="s">}</span>
 214     <span class="k">if</span> <span class="s">(</span><span class="i">$AllPreviousSmallerPathsBitVector</span><span class="i">-&gt;GetNumOfSetBits</span><span class="s">(</span><span class="s">)</span><span class="s">)</span> <span class="s">{</span>
 215       <span class="c"># Is current path a linear combination of smaller paths?</span>
 216       <span class="i">$AndBitVector</span> = <span class="i">$AllPreviousSmallerPathsBitVector</span> &amp;  <span class="i">$CurrentBitVector</span><span class="sc">;</span>
 217       <span class="k">if</span> <span class="s">(</span><span class="i">$CurrentBitVector</span><span class="i">-&gt;GetNumOfSetBits</span><span class="s">(</span><span class="s">)</span> == <span class="i">$AndBitVector</span><span class="i">-&gt;GetNumOfSetBits</span><span class="s">(</span><span class="s">)</span><span class="s">)</span> <span class="s">{</span>
 218         <span class="c"># Are all edges in the current path already present in smaller paths?</span>
 219         <span class="i">$CurrentEdgeIDsBitVector</span> = <span class="i">$CyclicPathEdgeIDsBitVectors</span>[<span class="i">$CurrentIndex</span>]<span class="sc">;</span>
 220         <span class="i">$AndBitVector</span> = <span class="i">$AllPreviousSmallerPathsEdgeIDsBitVector</span> &amp;  <span class="i">$CurrentEdgeIDsBitVector</span><span class="sc">;</span>
 221 
 222         <span class="k">if</span> <span class="s">(</span><span class="i">$CurrentEdgeIDsBitVector</span><span class="i">-&gt;GetNumOfSetBits</span><span class="s">(</span><span class="s">)</span> == <span class="i">$AndBitVector</span><span class="i">-&gt;GetNumOfSetBits</span><span class="s">(</span><span class="s">)</span><span class="s">)</span> <span class="s">{</span>
 223           <span class="c"># Current path doesn&#39;t qualify an independent path...</span>
 224           <span class="i">$SkipPath</span>{<span class="i">$CurrentIndex</span>} = <span class="n">1</span><span class="sc">;</span>
 225           <span class="k">next</span> <span class="j">CURRENT</span><span class="sc">;</span>
 226         <span class="s">}</span>
 227       <span class="s">}</span>
 228     <span class="s">}</span>
 229     <span class="c"># It&#39;s an independent cyclic path...</span>
 230     <span class="k">push</span> <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">IndependentCyclicPaths</span>}}<span class="cm">,</span> <span class="i">$CurrentCyclicPath</span><span class="sc">;</span>
 231   <span class="s">}</span>
 232   <span class="k">return</span> <span class="i">$This</span><span class="sc">;</span>
 233 <span class="s">}</span>
 234 
 235 <span class="c"># Setup a VertexID to index map...</span>
 236 <span class="c">#</span>
<a name="_SetupVertexIDsToIndicesMap-"></a> 237 <span class="k">sub </span><span class="m">_SetupVertexIDsToIndicesMap</span> <span class="s">{</span>
 238   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="cm">,</span> <span class="i">$PathGraph</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
 239   <span class="k">my</span><span class="s">(</span><span class="i">$LargestVertexIndex</span><span class="cm">,</span> <span class="i">@VertexIDs</span><span class="cm">,</span> <span class="i">%VertexIDsMap</span><span class="s">)</span><span class="sc">;</span>
 240 
 241   <span class="i">%VertexIDsMap</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span> <span class="i">@VertexIDs</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span> <span class="i">$LargestVertexIndex</span> = <span class="n">0</span><span class="sc">;</span>
 242 
 243   <span class="i">@VertexIDs</span> = <span class="i">$PathGraph</span><span class="i">-&gt;GetVertices</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 244   <span class="k">if</span> <span class="s">(</span>! <span class="i">@VertexIDs</span><span class="s">)</span> <span class="s">{</span>
 245     <span class="k">return</span> <span class="s">(</span>\<span class="i">%VertexIDsMap</span><span class="cm">,</span> <span class="i">$LargestVertexIndex</span><span class="s">)</span><span class="sc">;</span>
 246   <span class="s">}</span>
 247   <span class="i">@VertexIDsMap</span>{ <span class="i">@VertexIDs</span> } = <span class="s">(</span><span class="n">0</span> .. <span class="i">$#VertexIDs</span><span class="s">)</span><span class="sc">;</span>
 248   <span class="i">$LargestVertexIndex</span> = <span class="k">scalar</span> <span class="i">@VertexIDs</span><span class="sc">;</span>
 249 
 250   <span class="k">return</span> <span class="s">(</span>\<span class="i">%VertexIDsMap</span><span class="cm">,</span> <span class="i">$LargestVertexIndex</span><span class="s">)</span><span class="sc">;</span>
 251 <span class="s">}</span>
 252 
 253 <span class="c"># Setup a Edge to index map using paths associated to egdes in an intial</span>
 254 <span class="c"># path graph...</span>
 255 <span class="c">#</span>
<a name="_SetupEdgeIDsToIndicesMap-"></a> 256 <span class="k">sub </span><span class="m">_SetupEdgeIDsToIndicesMap</span> <span class="s">{</span>
 257   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="cm">,</span> <span class="i">$PathGraph</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
 258   <span class="k">my</span><span class="s">(</span><span class="i">$Path</span><span class="cm">,</span> <span class="i">$LargestEdgeIndex</span><span class="cm">,</span> <span class="i">@EdgeIDs</span><span class="cm">,</span> <span class="i">%EdgeIDsMap</span><span class="s">)</span><span class="sc">;</span>
 259 
 260   <span class="i">%EdgeIDsMap</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span> <span class="i">@EdgeIDs</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span> <span class="i">$LargestEdgeIndex</span> = <span class="n">0</span><span class="sc">;</span>
 261 
 262   <span class="i">@EdgeIDs</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 263   <span class="k">for</span> <span class="i">$Path</span> <span class="s">(</span><span class="i">$PathGraph</span><span class="i">-&gt;GetPaths</span><span class="s">(</span><span class="s">)</span><span class="s">)</span> <span class="s">{</span>
 264     <span class="k">push</span> <span class="i">@EdgeIDs</span><span class="cm">,</span> <span class="i">$This</span><span class="i">-&gt;_GetPathEdgeIDs</span><span class="s">(</span><span class="i">$Path</span><span class="s">)</span><span class="sc">;</span>
 265   <span class="s">}</span>
 266 
 267   <span class="k">if</span> <span class="s">(</span>! <span class="i">@EdgeIDs</span><span class="s">)</span> <span class="s">{</span>
 268     <span class="k">return</span> <span class="s">(</span>\<span class="i">%EdgeIDsMap</span><span class="cm">,</span> <span class="i">$LargestEdgeIndex</span><span class="s">)</span><span class="sc">;</span>
 269   <span class="s">}</span>
 270 
 271   <span class="i">@EdgeIDsMap</span>{ <span class="i">@EdgeIDs</span> } = <span class="s">(</span><span class="n">0</span> .. <span class="i">$#EdgeIDs</span><span class="s">)</span><span class="sc">;</span>
 272   <span class="i">$LargestEdgeIndex</span> = <span class="k">scalar</span> <span class="i">@EdgeIDs</span><span class="sc">;</span>
 273 
 274   <span class="k">return</span> <span class="s">(</span>\<span class="i">%EdgeIDsMap</span><span class="cm">,</span> <span class="i">$LargestEdgeIndex</span><span class="s">)</span><span class="sc">;</span>
 275 <span class="s">}</span>
 276 
 277 <span class="c"># Get path edge IDs or number of edges. The edge IDs are generated from</span>
 278 <span class="c"># edge vertices and correpond to VertexID1-VertexID2 where VertexID1 &lt;=</span>
 279 <span class="c"># VertexID2.</span>
 280 <span class="c">#</span>
<a name="_GetPathEdgeIDs-"></a> 281 <span class="k">sub </span><span class="m">_GetPathEdgeIDs</span> <span class="s">{</span>
 282   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="cm">,</span> <span class="i">$Path</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
 283   <span class="k">my</span><span class="s">(</span><span class="i">@EdgesVertexIDs</span><span class="cm">,</span> <span class="i">@EdgeIDs</span><span class="s">)</span><span class="sc">;</span>
 284 
 285   <span class="i">@EdgesVertexIDs</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span> <span class="i">@EdgeIDs</span> = <span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 286   <span class="i">@EdgesVertexIDs</span> = <span class="i">$Path</span><span class="i">-&gt;GetEdges</span><span class="s">(</span><span class="s">)</span><span class="sc">;</span>
 287   <span class="k">if</span> <span class="s">(</span>!<span class="i">@EdgesVertexIDs</span><span class="s">)</span> <span class="s">{</span>
 288     <span class="k">return</span> <span class="k">wantarray</span> ? <span class="i">@EdgeIDs</span> <span class="co">:</span> <span class="s">(</span><span class="k">scalar</span> <span class="i">@EdgeIDs</span><span class="s">)</span><span class="sc">;</span>
 289   <span class="s">}</span>
 290 
 291   <span class="c"># Set up edge IDs...</span>
 292   <span class="k">my</span><span class="s">(</span><span class="i">$Index</span><span class="cm">,</span> <span class="i">$VertexID1</span><span class="cm">,</span> <span class="i">$VertexID2</span><span class="cm">,</span> <span class="i">$EdgeID</span><span class="s">)</span><span class="sc">;</span>
 293 
 294   <span class="k">for</span> <span class="s">(</span><span class="i">$Index</span> = <span class="n">0</span><span class="sc">;</span> <span class="i">$Index</span> &lt; <span class="i">$#EdgesVertexIDs</span><span class="sc">;</span> <span class="i">$Index</span> += <span class="n">2</span><span class="s">)</span> <span class="s">{</span>
 295     <span class="i">$VertexID1</span> = <span class="i">$EdgesVertexIDs</span>[<span class="i">$Index</span>]<span class="sc">;</span> <span class="i">$VertexID2</span> = <span class="i">$EdgesVertexIDs</span>[<span class="i">$Index</span> + <span class="n">1</span>]<span class="sc">;</span>
 296     <span class="i">$EdgeID</span> = <span class="s">(</span><span class="i">$VertexID1</span> &lt;= <span class="i">$VertexID2</span><span class="s">)</span> ? <span class="q">&quot;$VertexID1-$VertexID2&quot;</span> <span class="co">:</span> <span class="q">&quot;$VertexID2-$VertexID1&quot;</span><span class="sc">;</span>
 297     <span class="k">push</span> <span class="i">@EdgeIDs</span><span class="cm">,</span> <span class="i">$EdgeID</span><span class="sc">;</span>
 298   <span class="s">}</span>
 299 
 300   <span class="k">return</span> <span class="k">wantarray</span> ? <span class="i">@EdgeIDs</span> <span class="co">:</span> <span class="s">(</span><span class="k">scalar</span> <span class="i">@EdgeIDs</span><span class="s">)</span><span class="sc">;</span>
 301 <span class="s">}</span>
 302 
 303 <span class="c"># Return an array containing references to cyclic paths or number of cylic paths...</span>
 304 <span class="c">#</span>
<a name="GetAllCyclicPaths-"></a> 305 <span class="k">sub </span><span class="m">GetAllCyclicPaths</span> <span class="s">{</span>
 306   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
 307 
 308   <span class="k">return</span> <span class="k">wantarray</span> ? <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}} <span class="co">:</span> <span class="k">scalar</span> <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}}<span class="sc">;</span>
 309 <span class="s">}</span>
 310 
 311 <span class="c"># Get cyclic paths which are independent. In otherwords, cycles which don&#39;t contain any other</span>
 312 <span class="c"># cycle as their subset...</span>
 313 <span class="c">#</span>
<a name="GetIndependentCyclicPaths-"></a> 314 <span class="k">sub </span><span class="m">GetIndependentCyclicPaths</span> <span class="s">{</span>
 315   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
 316 
 317   <span class="k">return</span> <span class="k">wantarray</span> ? <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">IndependentCyclicPaths</span>}} <span class="co">:</span> <span class="k">scalar</span> <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">IndependentCyclicPaths</span>}}<span class="sc">;</span>
 318 <span class="s">}</span>
 319 
 320 <span class="c"># Return a string containg data for CyclesDetection object...</span>
<a name="StringifyCyclesDetection-"></a> 321 <span class="k">sub </span><span class="m">StringifyCyclesDetection</span> <span class="s">{</span>
 322   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
 323   <span class="k">my</span><span class="s">(</span><span class="i">$CyclesDetectionString</span><span class="cm">,</span> <span class="i">$CyclesCount</span><span class="cm">,</span> <span class="i">$CyclicPath</span><span class="s">)</span><span class="sc">;</span>
 324 
 325   <span class="i">$CyclesCount</span> = <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}}<span class="sc">;</span>
 326   <span class="i">$CyclesDetectionString</span> = <span class="q">&quot;AllCycles: Count - $CyclesCount&quot;</span><span class="sc">;</span>
 327   <span class="k">for</span> <span class="i">$CyclicPath</span> <span class="s">(</span><span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">AllCyclicPaths</span>}}<span class="s">)</span> <span class="s">{</span>
 328     <span class="i">$CyclesDetectionString</span> .= <span class="q">&quot;; Cycle: &quot;</span> . <span class="k">join</span><span class="s">(</span><span class="q">&#39;-&#39;</span><span class="cm">,</span> <span class="i">$CyclicPath</span><span class="i">-&gt;GetVertices</span><span class="s">(</span><span class="s">)</span><span class="s">)</span><span class="sc">;</span>
 329   <span class="s">}</span>
 330 
 331   <span class="i">$CyclesCount</span> = <span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">IndependentCyclicPaths</span>}}<span class="sc">;</span>
 332   <span class="i">$CyclesDetectionString</span> .= <span class="q">&quot;\nIndependentCycles: Count - $CyclesCount&quot;</span><span class="sc">;</span>
 333   <span class="k">for</span> <span class="i">$CyclicPath</span> <span class="s">(</span><span class="i">@</span>{<span class="i">$This</span>-&gt;{<span class="w">IndependentCyclicPaths</span>}}<span class="s">)</span> <span class="s">{</span>
 334     <span class="i">$CyclesDetectionString</span> .= <span class="q">&quot;; Cycle: &quot;</span> . <span class="k">join</span><span class="s">(</span><span class="q">&#39;-&#39;</span><span class="cm">,</span> <span class="i">$CyclicPath</span><span class="i">-&gt;GetVertices</span><span class="s">(</span><span class="s">)</span><span class="s">)</span><span class="sc">;</span>
 335   <span class="s">}</span>
 336 
 337   <span class="k">return</span> <span class="i">$CyclesDetectionString</span><span class="sc">;</span>
 338 <span class="s">}</span>
 339 
 340 <span class="c"># Return a reference to new cycle detection object...</span>
<a name="Copy-"></a> 341 <span class="k">sub </span><span class="m">Copy</span> <span class="s">{</span>
 342   <span class="k">my</span><span class="s">(</span><span class="i">$This</span><span class="s">)</span> = <span class="i">@_</span><span class="sc">;</span>
 343   <span class="k">my</span><span class="s">(</span><span class="i">$NewCyclesDetection</span><span class="s">)</span><span class="sc">;</span>
 344 
 345   <span class="i">$NewCyclesDetection</span> = <span class="i">Storable::dclone</span><span class="s">(</span><span class="i">$This</span><span class="s">)</span><span class="sc">;</span>
 346 
 347   <span class="k">return</span> <span class="i">$NewCyclesDetection</span><span class="sc">;</span>
 348 <span class="s">}</span>
 349 
<a name="EOF-"></a></pre>
<p>&nbsp;</p>
<br />
<center>
<img src="../../../images/h2o2.png">
</center>
</body>
</html>
